<ActorFrame><children>

	<CODE Type="Quad" OnCommand="hidden,1"
	InitCommand="%function(self)
	
---------------------------------------------------------------------------------------
----------------------DON'T TOUCH IT KIDDO---------------------------------------------
---------------------------------------------------------------------------------------
			--dark + stealth combined into one neat mod_ease package
			function hideall(beat,len,s,t,ease,pn,sus,opt1,opt2,col)
				if not t then t = 'len' end
				if not s then s = 0 end
				if s == 0 then
					table.insert(mods_ease,{beat,len,0,100,'stealth'..col,t,ease,pn,sus,opt1,opt2});
					table.insert(mods_ease,{beat,len,0,100,'dark'..col,t,ease,pn,sus,opt1,opt2});
					table.insert(mods_ease,{beat,len,0,100,'hidenoteflashes'..col,t,ease,pn,sus,opt1,opt2});
				else			
					table.insert(mods_ease,{beat,len,100,0,'stealth'..col,t,ease,pn,sus,opt1,opt2});
					table.insert(mods_ease,{beat,len,100,0,'dark'..col,t,ease,pn,sus,opt1,opt2});
					table.insert(mods_ease,{beat,len,100,0,'hidenoteflashes'..col,t,ease,pn,sus,opt1,opt2});
				end
			end
			
			--copied sugarkill function from Celestial Harbor's Dark Sheep that actually works !
			function sugaroo_add(beat,len,speed,stealthvalmain,stealthvalsec,pn)
                local shp_switchtable = {'urld','rudl','dlru','ldur'}    
                local shp_counter = 0
                for i=beat,beat+len,speed do
                    local shp_swap = shp_switchtable[shp_counter+1]
                    switcheroo_add(i, shp_swap, -1, speed, pn)
                    if shp_counter == 3 then 
                        table.insert(mods,{i,speed,'*-1 '.. stealthvalmain ..'% stealth','len',pn});
                    else
                        table.insert(mods,{i,speed,'*-1 '.. stealthvalsec ..'% stealth','len',pn});
                    end
                    shp_counter = math.mod(shp_counter+1,4)
                end
                switcheroo_add(beat+len+speed, 'ldur', -1, speed, pn)
            end
			
			--spawnplayers, shamelessly stolen from hal
			function SpawnPlayers(beat,lower,upper,which,persist)
				local offset = -0.1
				local w = tostring(which)
				if which == 'despawn' then offset = -offset end
				mod_message(beat+offset,function(self)
					for i = lower,upper,1 do
						local a = Plr(i)
						if a then
							if w == 'spawn' then
								a:SetAwake(true)
							elseif w == 'despawn' then
								a:SetAwake(false)
							end
							a:zoom(0)
						end
					end
				end,true)
				mod_message(beat,function(self)
					for i = lower,upper,1 do
						local a = Plr(i)
						if a then
							if w == 'spawn' then
								a:hidden(0)
								a:zoom(1)
							elseif w == 'despawn' then
								a:zoom(0)
								a:hidden(1)
							end
						end
					end
				end,true)
			end
		
			function perframe( beat, endBeat )
				if GAMESTATE:GetSongBeat() < mod_firstSeenBeat+1 then return false end
				if not endBeat then endBeat = beat+1 end
				local cur = GAMESTATE:GetSongBeat();
				if cur>=beat and cur<endBeat then return true end
				return false
			end
			
			function mod_insert(beat,len,mod,t,pn)
				if not t then t = 'len' end
				table.insert(mods,{beat,len,mod,t,pn});
			end
			function mod2_insert(beat,len,mod,t,pn)
				if not t then t = 'len' end
				table.insert(mods2,{beat,len,mod,t,pn});
			end
			function mod_ease(beat,len,str1,str2,mod,t,ease,pn,sus,opt1,opt2)
				table.insert(mods_ease,{beat,len,str1,str2,mod,t,ease,pn,sus,opt1,opt2});
			end
			function mod_perframe(start_beat,end_beat,f)
				table.insert(mod_perframes,{start_beat,end_beat,f});
			end
			function mod_message(beat,msg,p)
				table.insert(mod_actions,{beat,msg,p});
			end
			
			function mod_blacklist(t,n)
				for i=1,table.getn(t) do
					if t[i] == n then
						return true
					end
				end
				return false
			end
			
			--how can I make simple m0d?
			--this will instantly turn a mod on to max and then quickly turn it off with the specified parameters
			--it's a simple mod
			
			function simple_m0d(beat,strength,mult,mod,pn)
				if not strength then strength = 400 end
				if not mult then mult = 1 end
				if not mod then mod = 'drunk' end
				
				local alive = math.max(2*mult*math.abs(strength)/100,0.25)
				
				table.insert(mods,{beat,0.3,'*100000 '..strength..' '..mod,'len',pn});
				table.insert(mods,{beat+.2,alive,'*'..((1/mult)*math.abs(strength)/100)..' no '..mod,'len',pn});
			end
			
			function simple_m0d2(beat,strength,mult,mod,pn)
				if not strength then strength = 400 end
				if not mult then mult = 1 end
				if not mod then mod = 'drunk' end
				
				local alive = math.max(10*mult*math.abs(strength)/100,0.25)
				
				table.insert(mods,{beat,0.3,'*'..math.abs(strength/10)..' '..strength..' '..mod,'len',pn});
				table.insert(mods,{beat+.3,alive,'*'..((1/mult)*math.abs(strength)/100)..' no '..mod,'len',pn});
			end
			
			function simple_m0d3(beat,strength,duration,bpm,mod,pn)
				if not strength then strength = 400 end
				if not duration then duration = 1 end
				if not bpm then bpm = 120 end
				if not mod then mod = 'drunk' end
				
				local alive = duration * (60/bpm)
				local str = (1/(duration * 60/bpm)) * (math.abs(strength)/100)
				
				table.insert(mods,{beat-duration,duration,'*'..str..' '..strength..' '..mod,'len',pn});
				table.insert(mods,{beat,duration*1.1,'*'..str..' no '..mod,'len',pn});
			end
			
			--alternates a mod back and forth before resetting to 0
			--beat,num,div,amt,speed,mod,pn
			function mod_wiggle(beat,num,div,amt,speed,mod,pn,first)
				if not speed then speed = 1 end
				local fluct = 1
				for i=0,(num-1) do
					b = beat+(i/div)
					local m = 1
					if i==0 and not first then m = 0.5 end
					table.insert(mods,{b,1,'*'..math.abs(m*speed*amt/10)..' '..(amt*fluct)..' '..mod..'','len',pn});
					fluct = fluct*-1;
				end
				table.insert(mods,{beat+(num/div),1,'*'..math.abs(amt*speed/20)..' no '..mod..'','len',pn});
			end
			
			--like wiggle, but springier
			--beat,strength,num,mod,pn
			function mod_spring(beat,strength,num,mod,pn)
				local fluct = 1;
				for i=0,num do
					if i==0 then mult = 0.5 else mult = 1 end
					local amt = (num-i)/num
					local b = beat+(0.05*i)
					
					table.insert(mods,{b,0.3,'*'..math.max(math.abs(1000*strength*mult*amt),1)..' '..(strength*amt*fluct)..' '..mod,'len',pn});
					
					fluct = fluct*-1;
				end
			end
			
			function mod_springt(beat,strength,dur,mod,pn)
				local fluct = 1;
				dur = math.max(dur,0.02)
				for i=0,dur-.01,0.02 do
					local mult = 1;
					local amt = (dur-i)/dur
					local b = beat+i
					
					table.insert(mods2,{b,0.02,'*100000 '..(strength*amt*fluct)..' '..mod,'len',pn});
					
					fluct = fluct*-1;
				end
				table.insert(mods2,{beat+dur,0.1,'*100000 no '..mod,'len',pn});
			end
			
			function mod_springt2(beat,strength,dur,mod,pn)
				local fluct = 1;
				for i=0,dur-.01,0.02 do
					local b = beat+i
					
					table.insert(mods2,{b,0.02,'*100000 '..(strength*fluct)..' '..mod,'len',pn});
					
					fluct = fluct*-1;
				end
				table.insert(mods2,{beat+dur,0.1,'*100000 no '..mod,'len',pn});
			end
			
			--beat,strength,num,period,mod,pn
			function mod_spring_adjustable(beat,strength,num,period,mod,pn, first)
				local fluct = 1;
				for i=0,num do
					if i==0 then mult = 0.5 else mult = 1 end
					local amt = (num-i)/num
					local b = beat+(period*0.5*i)
					
					local m = 1
					if i==0 and not first then m = 0.5 end
					
					table.insert(mods,{b,0.3,'*'..math.max(m*math.abs((0.2/period)*strength*mult*amt),1)..' '..(strength*amt*fluct)..' '..mod,'len',pn});
					
					fluct = fluct*-1;
				end
			end
			
			--turns on beat for the beat specified, at the desired strength	
			function mod_beat(beat,strength,pn)
				if not strength then strength = 1000 end;
				table.insert(mods,{beat-.5,1,'*10000 '..strength..' beat','len',pn});
				table.insert(mods,{beat+.5,0.25,'*10000 no beat','len',pn});
			end
			
			function switcheroo_reset()
				switcheroo_flip = {0,0,0};
				switcheroo_invert = {0,0,0};
			end
			
			switcheroo_flip = {0,0,0};
			switcheroo_invert = {0,0,0};
			
			switcheroo_width = 1;
				
			switcheroos = {normal = {0,0}, ldur = {0,0}, reset = {0,0},
				flip = {100,0}, rudl = {100,0}, invert = {0,100}, dlru = {0,100},
				ludr = {25,-75}, rdul = {75,75}, drlu = {25,125}, ulrd = {75,-125}, urld = {100,-100}}
			function switcheroo_add(beat,which,speed,len,pn)

				if not speed then speed = 1000000 end
				
				local mpn = 3
				if pn then mpn = pn end
				
				local w = {0,0}
				
				if type(which) == 'string' then w = switcheroos[which] end
				if type(which) == 'table' then w = which end
				
				if w then
					local targf = (switcheroos[which][1]*switcheroo_width) + ( 50 - switcheroo_width*50 )
					local targi = (switcheroos[which][2]*switcheroo_width)
					local sw_modlist = ''
					if switcheroo_flip[mpn] ~= targf then
						sw_modlist = sw_modlist..'*'..(0.01*speed*math.abs(targf-switcheroo_flip[mpn]))..' '..(targf)..' flip,'
					else
						sw_modlist = sw_modlist..'*1 '..(targf)..' flip,'
					end
					if switcheroo_invert[mpn] ~= targi then
						sw_modlist = sw_modlist..'*'..(0.01*speed*math.abs(targi-switcheroo_invert[mpn]))..' '..(targi)..' invert'
					else
						sw_modlist = sw_modlist..'*1 '..(targi)..' invert'
					end
					table.insert(mods,{beat,len,sw_modlist,'len',pn});
					
					--Trace('SPEED: '..(0.01*speed*math.abs(targf-switcheroo_flip)));
					Trace(sw_modlist);
					
					if mpn == 3 then
						for apn=1,3 do
							switcheroo_flip[apn] = targf;
							switcheroo_invert[apn] = targi;
						end
					else
						switcheroo_flip[mpn] = targf;
						switcheroo_invert[mpn] = targi;
					end
				
				end
				
			end
			
			--portable version of the effect from sugarkill X
			function mod_sugarkiller(beat,duration,speed,minstealth,maxstealth,pn)
				if not minstealth then minstealth = 50 end
				if not maxstealth then maxstealth = 85 end
				if not speed then speed = 1 end
				local dur = duration
				if not dur then dur = 1 end
				dur = dur*speed;
				for i=0,math.max(dur-1,0) do
					table.insert(mods,{beat+(i*0.5),.25/speed,'*10000 Invert, *10000 no flip, *10000 '..maxstealth..'% Stealth','len',pn})
					table.insert(mods,{beat+(i*0.5)+.25/speed,.25/speed,'*10000 Flip, *10000 no invert, *10000 '..maxstealth..'% Stealth','len',pn})
					table.insert(mods,{beat+(i*0.5)+.50/speed,.25/speed,'*10000 Flip,*10000 -100% Invert,*10000 '..maxstealth..'% Stealth','len',pn})
					if i == math.max(dur-1,0) then
						table.insert(mods,{beat+(i*0.5)+.75/speed,.25/speed,'*10000 No Flip,*10000 No Invert,*10000 no Stealth','len',pn})
					else
						table.insert(mods,{beat+(i*0.5)+.75/speed,.25/speed,'*10000 No Flip,*10000 No Invert,*10000 '..minstealth..'% Stealth','len',pn})
					end
				end
			end
			
			-- hey alright
			function modulo(a, b)
				return a - math.floor(a/b)*b;
			end
			
			-- counterrotation function by BrotherMojo
			-- returns confusion(x/y/z)offsets to counteract the given rotations
			function reverseRotation(angleX, angleY, angleZ)
				local DEG_TO_RAD = math.pi / 180
				angleX, angleY, angleZ = DEG_TO_RAD * angleX, DEG_TO_RAD * angleY, DEG_TO_RAD * angleZ
				local sinX = math.sin(angleX);
				local cosX = math.cos(angleX);
				local sinY = math.sin(angleY);
				local cosY = math.cos(angleY);
				local sinZ = math.sin(angleZ);
				local cosZ = math.cos(angleZ);
				return 100 * math.atan2(-cosX*sinY*sinZ-sinX*cosZ,cosX*cosY), 100 * math.asin(-cosX*sinY*cosZ+sinX*sinZ), 100 * math.atan2(-sinX*sinY*cosZ-cosX*sinZ,cosY*cosZ)
			end
			
			--dumb random function
			function randomXD(t)
				if t == 0 then return 0.5 else
				return modulo(math.sin(t * 3229.3) * 43758.5453, 1) end
			end
			
			function mod_bounce(beat,length,start,apex,mod,ease,pn)
				mod_ease(beat, (length/2), start, apex, tostring(mod), 'len', _G['out'..ease],pn)
				mod_ease(beat+(length/2), (length/2), apex, start, tostring(mod), 'len', _G['in'..ease],pn,0.2)
			end
			
			function func_bounce(beat,length,start,apex,func,ease)
				func_ease(beat,(length/2),start,apex,func,'len',_G['out'..tostring(ease)])
				func_ease(beat+(length/2),(length/2),apex,start,func,'len',_G['in'..tostring(ease)],nil,0.2)
			end

			--stolen from hal thank you very cool
			function ease_wiggle(beatS,beatE,amt,inc,str,ease,len,pn)
				local rotStart = 0
				local prevRot = amt
				local curRot = -amt
				local measure = tostring(len)
				local asdf = 0
				if measure == 'end' then
					asdf = beatE
				elseif measure == 'len' then
					asdf = (beatS+beatE)
				end
				for i = beatS,asdf,inc do
					if i == beatS then
						rotStart = 0
					else
						rotStart = prevRot
					end
					if i == asdf then
						rotEnd = 0
					else
						rotEnd = curRot
					end
						mod_ease(i-inc, inc, rotStart, rotEnd, str, 'len', ease, pn)
						prevRot = prevRot *-1
						curRot = curRot *-1
				end
			end

			function ease_wiggleAbs(beatS,beatE,amt,inc,str,ease,len,pn)
				local rotStart = 0
				local prevRot = 0
				local curRot = amt
				local counter = 1
				local measure = tostring(len)
				local asdf = 0
				if measure == 'end' then
					asdf = beatE
				elseif measure == 'len' then
					asdf = (beatS+beatE)
				end
				for i = beatS,asdf-inc,inc do
					if counter == -1 then
						preRot,curRot = amt, 0
					elseif counter == 1 then
						preRot,curRot = 0, amt
					end
					mod_ease(i, inc, preRot, curRot, str, 'len', ease, pn)
					counter = counter*-1
				end
			end
---------------------------------------------------------------------------------------
----------------------END DON'T TOUCH IT KIDDO-----------------------------------------
---------------------------------------------------------------------------------------
		
	end"
	/>

</children></ActorFrame>