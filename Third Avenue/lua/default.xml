<ActorFrame
InitCommand="%function(self)

	nitg_version = FUCK_EXE and tonumber(GAMESTATE:GetVersionDate()) >= 20180617 --NotITG version number to check for, v3 by default
	
	if not nitg_version then
		SCREENMAN:SystemMessage('Outdated version of NotITG detected, mods will not work');
	end
	
	songName = GAMESTATE:GetCurrentSong():GetSongDir();
	
	m_bl = 60/145 --use this to define length of a beat for use in the rest of the song
	sw = SCREEN_WIDTH
	sh = SCREEN_HEIGHT --shortcuts
	
	function Plr(pn)
		return _G['P'..pn]
	end
end"
><children><ActorFrame Condition="nitg_version"
OnCommand="%function(self)
	nvidia = false
	alphamult = 1
	if string.find(string.lower(PREFSMAN:GetPreference('LastSeenVideoDriver')), 'nvidia') or string.find(string.lower(DISPLAY:GetVendor()),'nvidia') then
		Trace('NVidia graphics driver detected.')
		Trace('AFT multiplier set to 0.9')
		nvidia = true
		alphamult = 0.9
	end
	if not string.find(string.lower(PREFSMAN:GetPreference('VideoRenderers')), 'opengl')
	or string.find(string.lower(PREFSMAN:GetPreference('VideoRenderers')), 'd3d')
	and string.find(string.lower(PREFSMAN:GetPreference('VideoRenderers')), 'opengl') 
	and string.find(string.lower(PREFSMAN:GetPreference('VideoRenderers')), 'd3d') < 
	string.find(string.lower(PREFSMAN:GetPreference('VideoRenderers')), 'opengl') then
		SCREENMAN:SystemMessage('D3D Video Renderer detected. Expect textures to fail.');
	end
end"
><children>

	<Layer
		Type="Quad"
		InitCommand="hidden,1"
		OnCommand="sleep,1000"
	/>
	
	<Layer File="modhelpers" />
	<Layer File="easing" />	
	<Layer File="spellcards" />
	
	<Layer
		Type="Quad"
		OnCommand="hidden,1"
		InitCommand="%function(self)
		
			checked = false;
		
			---------------------------------------------------------
			---------DOCUMENTATION-----------------------------------
			---------------------------------------------------------
			
			--function perframe( beat, endBeat )
				--return true if the current beat is between 'beat' and 'endBeat'
			
			--function mod_shader(beat,key,which)
				--turn on shader key at specified beat (up to 10 keys available, defined by 'which' = 0-9
				
			--function mod_insert(beat,len,mod,len_or_end,pn)
				--insert mod into beat mods table
			--function mod_insert2(time,len,mod,len_or_end,pn)
				--insert mod into time mods table
			--function mod_ease(beat, len, start_strength, end_strength, mod, len_or_end, ease_type, pn, sustain, opt1, opt2)
				--insert mod into ease mods table
			--function mod_perframe(start, end, function(beat, deltatime))
				--insert function into perframe reader
				
			--function mod_message(beat,msg,persistent)
				--insert something into the actions table.
				--msg can also be a function. If string, a message gets broadcast at that beat
				--if 'persistent' is true, message will run even if editor starts at a beat past it
				
			--function mod_blacklist(t,n)
				--check if number n occurs in table t
				--useful for doing 'every beat EXCEPT the contents of t'
				
			--function simple_m0d(beat,strength,mult,mod)
			--function simple_m0d2(beat,strength,mult,mod,pn)
			--function simple_m0d3(beat,strength,duration,bpm,mod,pn)
				--activate mods at specific beat but also deactivate them
				
			--function mod_wiggle(beat,num,div,amt,speed,mod,pn,first)
				--alternates a mod back and forth before resetting to 0
				
			--function mod_spring(beat,strength,num,mod,pn)
				--like mod_wiggle, but springier
			
			--function mod_springt(time,strength,dur,mod,pn)
				--time-based per-frame alternating mod that decreases based on how much time is left.
					--think doorstopper
			
			--function mod_springt2(time,strength,dur,mod,pn)
				--time-based per-frame alternating mod
			
			--function mod_spring_adjustable(beat,strength,num,period,mod,pn, first)
				--it's not very good
			
			--function mod_beat(beat,strength,pn)
				--turns on beat for the beat specified, at the desired strength	
			
			--function switcheroo_add(beat,which,speed,len,pn)
				--adds a column swap at the desired beat
			--[[	switcheroos = {normal = {0,0}, ldur = {0,0}, reset = {0,0},
					flip = {100,0}, rudl = {100,0}, invert = {0,100}, dlru = {0,100},
					ludr = {25,-75}, rdul = {75,75}, drlu = {25,125}, ulrd = {75,-125}, urld = {100,-100}}
			]]
			
			--function mod_sugarkiller(beat,duration,speed,minstealth,maxstealth,pn)
				--portable version of the effect from sugarkill X
			
			--NEW**
			--function sugaroo_add(beat,len,speed,stealthvalmain,stealthvalsec,pn)
				--a version of mod_sugarkiller stoken from Daikyi that actually works !
				
			--function mod_bounce(beat,length,start,apex,mod,ease_type,pn)
			--function func_bounce(beat,length,start,apex,function,ease_type)
				--eases out from start to apex, then eases back in from apex to start
				--ease_type should be a string, i.e. 'Quad', 'Cubic', 'Circ'
			
			
			
			--function modulo(a, b)
				--returns the remainder when a is divided by b, works properly with negatives unlike math.mod
			
			--function randomXD(t)
				--returns a pseudo-random number between 0 and 1 seeded based on the given argument
				--returns 0.5 if t is 0 (useful sometimes!)
			
			--NEW**
			--function hideall(beat,len,s,t,ease,pn,sus,opt1,opt2,col)
				--dark + stealth in one neat mod_ease package
				--s = 1 is 100% stealth
				--t = len/end
				--i probably need to update this function to be more versatile
				
			--NEW**
			--function SpawnPlayers(beat,lower,upper,which,persist)
				--stolen from hal
				--lower/upper is player numbers
				--which: 'spawn'/'despawn'
				--persist should probably be true
			---------------------------------------------------------
			--------END DOCUMENTATION--------------------------------
			---------------------------------------------------------
			
			
			
			
			
			
			
			
			
			init_modsp1 = '';
			init_modsp2 = '';
			
			mod_plr = {};
			
			mod_firstSeenBeat = GAMESTATE:GetSongBeat(); --necessary to prevent long freezes
			
			
---------------------------------------------------------------------------------------
----------------------Begin tables 'n stuff--------------------------------------------
---------------------------------------------------------------------------------------

			--beat based mods
			--{beat_start, beat_end, mods, len_or_end, player_number}
			mods = {
				{0,9999,'*2 2x, *-1 overhead, *-1 approachtype, *-1 dizzyholds, *-1 stealthpastreceptors, *-1 modtimer,*-1 300% zoomz, *-1 90% hidemines','end'},
			}
			
			--beat-based ease mods
			--{beat_start, beat_end, mod_start, mod_end, mod/function, len_or_end, ease_type, player_number, sustainbeats, optional_param1, optional_param2}
			--valid ease types are:
				--linear
				--inQuad    outQuad    inOutQuad    outInQuad
				--inCubic   outCubic   inOutCubic   outInCubic
				--inQuart   outQuart   inOutQuart   outInQuart
				--inQuint   outQuint   inOutQuint   outInQuint
				--inSine    outSine    inOutSine    outInSine
				--inExpo    outExpo    inOutExpo    outInExpo
				--inCirc    outCirc    inOutCirc    outInCirc
				--inElastic outElastic inOutElastic outInElastic    --can take 2 optional parameters - amplitude & period
				--inBack    outBack    inOutBack    outInBack       --can take 1 optional parameter  - spring amount
				--inBounce  outBounce  inOutBounce  outInBounce
				
			mods_ease = {
				-- EXAMPLE TWEEN: from beat 0 to 4, make rotationz go from 360 to 0 with the inOutBack tween
				--{0, 4, 360, 0, 'rotationz', 'len', inOutBack},
				
				-- EXAMPLE TWEEN: from beat 4 to 8, rotate topscreen from 360 to 0 with the outBack tween
				--{4, 4, 360, 0, function(a) SCREENMAN:GetTopScreen():rotationz(a) end, 'len', outBack},
			}
			
			--time based mods
			mod_time = 0;
			--{time_start, time_end, mods, len_or_end, player_number}
			mods2 = {
			}
			
			-- you can now write perframe stuff without having to scroll down!
			-- {beat_start,beat_end,function(beat,deltatime)}
			mod_perframes = {
				--{18,24,function(beat,deltatime)
					-- do stuff every frame from beat 18-24
					-- print(beat,deltatime)
				--end},
			}
			
			--this is both a message broadcaster and a function runner
			--if you put {beat,'String'}, then 'String' is broadcast as a message on that beat
			--if you put {beat,function() somecode end}, then function() is run at that beat
			--see example on beat 0
			
			curaction = 1;
			--{beat,thing,persists}
			mod_actions = {
				{0,'GetProxy',true},
				{0,function()
					for pn=1,2 do
						local a = Plr(pn)
						if a then
							a:GetChild('Judgment'):hidden(1)
							a:GetChild('Combo'):hidden(1)
							a:SetFarDist(10000)
						end
					end
					
					for pn=1,2 do
						local d = 0.25; if pn == 2 then d = 0.75 end
						local b = _G['jud'..pn..'p']
						if b then
							b:hidden(0);
							b:basezoomx(0.75);
							b:basezoomy(0.75);
							b:x(SCREEN_WIDTH*d)
							b:y(SCREEN_HEIGHT*0.5)
						end
						local c = _G['com'..pn..'p']
						if c then
							c:hidden(0);
							c:basezoomx(0.75);
							c:basezoomy(0.75);
							c:x(SCREEN_WIDTH*d)
							c:y(SCREEN_HEIGHT*0.5)
						end
					end
				end,true},
			}
			
---------------------------------------------------------------------------------------
--***              	   begin Real Shit          	    		                  ***--
---------------------------------------------------------------------------------------
			local me = mod_ease
			local mb = mod_bounce
			local m = mod_insert
			local mm = mod_message
			local mpf = mod_perframe
			
			--intro lol
			m(0,26,'*-1 -0.001% tipsyspeed,*-1 150% tipsyoffset','len')
			
			for i = 0,14,2 do
				mb(i,1,0,50,'tinyy','Cubic')
				mb(i,1,0,-50,'tinyx','Cubic')
			end
			for i = 0,26,2 do
				local m = 1
				if modulo(i/2,2) == 1 then m = -1 end
				
				mb(i,1,0,110,'flip','Cubic')
				mb(i,1.25,0,40*m,'rotationx','Cubic')
				
				mb(i+1,0.75,0,150,'tipsy','Expo')
				mb(i+1.5,1.25,0,-150,'tipsy','Expo')
				
				for c = 0,3 do					
					local d = c/5
					local e = math.floor(c-3)/5
					me(i,1.5,70+d,0,'confusionzoffset'..c,'len',outCubic,1)
					me(i,1.5,-70+d,0,'confusionzoffset'..c,'len',outCubic,2)
					me(i+1,1.5,(-70+e),0,'confusionzoffset'..c,'len',outCubic,1)
					me(i+1,1.5,(70+e),0,'confusionzoffset'..c,'len',outCubic,2)
				end
			end
			
			for i = 16,26,2 do
				me(i,1,-300,0,'tiny0','len',outSine)
				me(i,1,-300,0,'tiny2','len',outSine)
				me(i+1,1,-300,0,'tiny1','len',outSine)
				me(i+1,1,-300,0,'tiny3','len',outSine)
				
				me(i,1,0,30,'rotationy','len',outSine)
				me(i+1,1,0,-30,'rotationy','len',outSine)
			end
			
			me(27.5,0.5,-30,0,'rotationy','len',outSine)
			
			me(28.75,0.75,628,314/2,'confusionzoffset','len',outBack)
			mb(28.75,0.75,0,50,'rotationy','Expo')
			me(29.5,0.75,314/2,314,'confusionzoffset','len',outBack)
			mb(29.5,0.75,0,-50,'rotationy','Expo')
			me(30.25,0.75,314,0,'confusionzoffset','len',outBack)
			mb(30.25,0.75,0,50,'rotationy','Expo')
			
			for i = 28.75,30.25,0.75 do
				mb(i,0.75,30,0,'dizzy','Expo')
				me(i,0.75,-300,0,'tiny','len',outSine)
			end
			
			--mb(31,1,0,500,'drunkz','Cubic',1)
			--mb(31,1,0,-500,'drunkz','Cubic',2)
			--mb(31,1,0,100,'tipsy','Cubic',2)
			--mb(31,1,0,-100,'tipsy','Cubic',1)
			me(31,1,-300,0,'tiny','len',inCubic)
			me(31,1,0,-80,'rotationx','len',outExpo,nil,31)
			me(31,1,0,140,'confusionxoffset','len',outExpo,nil,31)
			me(31,1,0,300,'bumpy','len',outExpo,1,31)
			me(31,1,0,-300,'bumpy','len',outExpo,2,31)
			me(31,1,0,50,'brake','len',outExpo,2,31)
			me(31,1,SCREEN_CENTER_X*1.5,SCREEN_CENTER_X,function(a)
				local b = Plr(1)
				if b then b:x(a) end
			end,'len',outBack)	
			me(31,1,SCREEN_CENTER_X*0.5,SCREEN_CENTER_X,function(a)
				local b = Plr(2)
				if b then b:x(a) end
			end,'len',outBack)
			mm(32,function()
				for pn = 1, 2 do
					local a = Plr(pn)
					if a then
						a:x(SCREEN_CENTER_X)
					end
				end
			end,true)
			--me(31,1,0,-50,'flip','len',outExpo,nil,32)
			
			--funny 
			m(31,64,'*-1 500% bumpyperiod,*-1 90% hideholds','end')
			m(31,64,'*-1 200% beatz','end',1)
			m(31,64,'*-1 -200% beatz','end',2)
			for i = 32,62,2 do
				me(i,1,0,100,'stealth','len',outExpo,2)
				me(i,1,90,100,'hideholds','len',outExpo,2)
				me(i,1,100,0,'stealth','len',outExpo,1)
				me(i,1,100,90,'hideholds','len',outExpo,1)
				
				me(i+1,1,100,0,'stealth','len',outExpo,2)
				me(i+1,1,100,90,'hideholds','len',outExpo,2)
				me(i+1,1,0,100,'stealth','len',outExpo,1)
				me(i+1,1,90,100,'hideholds','len',outExpo,1)
				
				me(i,1,30,0,'rotationy','len',outExpo)
				me(i+1,1,-30,0,'rotationy','len',outExpo)
			end
			
			--build brown bricks in minecraft in the prarie			
			me(63,1,-80,0,'rotationx','len',inExpo,nil)
			me(63,1,140,0,'confusionxoffset','len',inExpo,nil)
			me(63,1,300,0,'bumpy','len',inExpo,1)
			me(63,1,-300,0,'bumpy','len',inExpo,2)
			me(63,1,50,0,'brake','len',inExpo,2)
			
			me(64,92,0,-50,'flip','end',linear)
			me(64,92,0,-80,'rotationx','end',inSine)
			for i = 64,91 do
				me(i,1,100,50,'brake','len',outCubic)
				me(i,1,120,100,'zoomy','len',outCubic)
				me(i,1,100,120,'zoomx','len',inCubic)
				me(i,1,-200,0,'tiny','len',outCubic)
				me(i,1,-1000,0,'tinyz','len',outCubic)
			end
			for i = 64,78,2 do
				mb(i,1,0,10,'rotationz','Expo')
				me(i,1,0,50,'skewx','len',outExpo)
				mb(i+1,1,0,-10,'rotationz','Expo')
				me(i+1,1,0,-50,'skewx','len',outExpo)
				
				me(i,1,100,0,'confusionzoffset','len',outSine)
				me(i+1,1,-100,0,'confusionzoffset','len',outSine)
			end
			
			for i = 80,90,2 do
				mb(i,1,0,20,'rotationy','Expo')
				me(i,1,0,70,'skewx','len',outExpo)
				mb(i+1,1,0,-20,'rotationy','Expo')
				me(i+1,1,0,-70,'skewx','len',outExpo)
			end
			m(80,92,'*-1 1000% bumpyperiod,*-1 200% drawsize','end')
			me(80,92,0,1500,'bumpy','end',inSine)
			
			for i = 88,90,2 do
				me(i,1,-360,-180,'rotationz','len',outExpo)
				me(i+1,1,-180,0,'rotationz','len',outExpo)
			end
			me(92,1,1500,0,'bumpy','len',outExpo)
			me(92,1,-80,0,'rotationx','len',outExpo)
			me(92,1,-50,0,'flip','len',outExpo)
			
			m(92,1,'*-1 100% drawsize','len')
			for c = 0,3 do
				me(92+c/4,92+c/4+0.5,0,400,'movey'..c,'end',outCubic,nil,94)
				mb(92+c/4,0.5,0,-200,'tinyy'..c,'Back')
				mb(92+c/4,0.5,0,50,'tinyx'..c,'Back')
			end
			mb(93.5,0.5,100,150,'zoomx','Expo')
			mb(93.5,0.5,0,110,'flip','Expo')
			me(94,1,400,0,'movey0','len',outCubic)
			me(94,1,400,0,'movey1','len',outCubic)
			mb(94,0.5,0,-200,'tinyy0','Back')
			mb(94,0.5,0,50,'tinyx1','Back')
			mb(94,0.75,0,20,'rotationz','Expo')
			
			me(94.75,1,400,0,'movey2','len',outExpo)
			me(94.75,1,400,0,'movey3','len',outExpo)
			mb(94.75,0.5,0,-200,'tinyy2','Back')
			mb(94.75,0.5,0,50,'tinyx3','Back')
			mb(94.75,0.75,0,-20,'rotationz','Expo')
			
			me(94,0.75,100,120,'zoom','len',outBack)
			me(94.75,0.75,120,150,'zoom','len',outBack,nil,0.5)
			me(96,1,140,50,'zoom','len',outExpo)
			me(97,1,50,100,'zoom','len',outExpo)
			
			weenie = {
				{0,0},
				{0.25,1},
				{0.75,2},
				{1,3},
			}
			function trd_swaps(beat,len,swap,transition) --funny modelista part
				--swap is a string, flip or invert
				if swap == 'flip' then
					for i = beat,beat+len do
						me(i,0.5,0,314,'confusionzoffset','len',outExpo)
						me(i+0.5,0.5,314,0,'confusionzoffset','len',outExpo)
					end
				else 
					for i = beat,beat+len do
						me(i,0.5,0,-314/2,'confusionzoffset0','len',outExpo)
						me(i,0.5,0,-314/2,'confusionzoffset3','len',outExpo)
						me(i,0.5,0,314/2,'confusionzoffset1','len',outExpo)
						me(i,0.5,0,314/2,'confusionzoffset2','len',outExpo)
						
						me(i+0.5,0.5,-314/2,0,'confusionzoffset0','len',outExpo)
						me(i+0.5,0.5,-314/2,0,'confusionzoffset3','len',outExpo)
						me(i+0.5,0.5,314/2,0,'confusionzoffset1','len',outExpo)
						me(i+0.5,0.5,314/2,0,'confusionzoffset2','len',outExpo)
					end
				end
				for i = beat,beat+len do
					me(i,0.5,0,100,swap,'len',outExpo)
					me(i,0.5,0,50,'stealth','len',outExpo)
					me(i+0.5,0.5,100,0,swap,'len',outExpo)
					me(i+0.5,0.5,50,0,'stealth','len',outExpo)
				end
				
				local tstart = beat + len + 1
				if transition == 1 then --good coding
					me(tstart,0.5,150,0,'tipsy','len',inCirc)
					me(tstart,0.5,-50,0,'flip','len',inCirc)
					me(tstart+0.5,0.5,-150,0,'tipsy','len',inCirc)
					me(tstart+0.5,0.5,-50,0,'invert','len',inCirc)
					
					me(tstart,0.5,-100,0,'tiny0','len',inCirc)
					me(tstart,0.5,-100,0,'tiny2','len',inCirc)
					me(tstart+0.5,0.5,-100,0,'tiny1','len',inCirc)
					me(tstart+0.5,0.5,-100,0,'tiny3','len',inCirc)
				elseif transition == 2 then --same as 1, but reversed
					me(tstart,0.5,-150,0,'tipsy','len',inCirc)
					me(tstart,0.5,-50,0,'flip','len',inCirc)
					me(tstart+0.5,0.5,150,0,'tipsy','len',inCirc)
					me(tstart+0.5,0.5,-50,0,'invert','len',inCirc)
					
					me(tstart,0.5,-100,0,'tiny1','len',inCirc)
					me(tstart,0.5,-100,0,'tiny3','len',inCirc)
					me(tstart+0.5,0.5,-100,0,'tiny0','len',inCirc)
					me(tstart+0.5,0.5,-100,0,'tiny2','len',inCirc)
				elseif transition == 3 then
					for i = tstart, tstart+2, 2 do
						mb(i,1,0,400,'drunkz','Expo')
						--mb(i,1,0,30,'rotationy','Expo')
						mb(i,1,0,-20,'invert','Expo')
						mb(i+1,1,0,-400,'drunkz','Expo')
						--mb(i+1,1,0,-30,'rotationy','Expo')
						mb(i,1,0,20,'invert','Expo')
					end
				elseif transition == 4 then --reverse of t3					
					for i = tstart, tstart+2, 2 do
						mb(i,1,0,-400,'drunkz','Expo')
						mb(i,1,0,-20,'invert','Expo')
						mb(i+1,1,0,400,'drunkz','Expo')
						mb(i,1,0,20,'invert','Expo')
					end
				elseif transition == 5 then 
					for d,v in ipairs(weenie) do --d
						me(tstart+v[1],0.5,-200,0,'tiny'..v[2],'len',inCirc)
					end
					mb(tstart,0.75,0,300,'tipsy','Expo')
					mb(tstart,0.75,0,-200,'confusionzoffset','Expo')
				else --reverse of 5
					for d,v in ipairs(weenie) do --d
						local e = math.floor(3-v[2]) --good variable naming
						me(tstart+v[1],0.5,-200,0,'tiny'..e,'len',inCirc)
					end
					mb(tstart,0.75,0,-300,'tipsy','Expo')
					mb(tstart,0.75,0,200,'confusionzoffset','Expo')
				end
			end
			trd_swaps(97,4,'invert',1)
			trd_swaps(105,4,'invert',5)
			trd_swaps(113,4,'flip',2)
			trd_swaps(121,2,'flip',3)
			
			
			mb(97,1,0,-20,'rotationz','Expo')
			for i = 98,100,2 do
				mb(i,1,0,20,'rotationz','Expo')
				mb(i+1,1,0,-20,'rotationz','Expo')
				
				mb(i,1,100,120,'zoom','Cubic')
				mb(i+1,1,100,120,'zoom','Cubic')
			end
			me(103,1,0,99.9,'reverse','len',outExpo,nil,8)
			mb(103,1,0,-150,'tinyy','Cubic')
			mb(103,1,0,-50,'tinyx','Cubic')			
			
			me(104,1,100,50,'zoom','len',outExpo)
			me(105,1,50,100,'zoom','len',outExpo)
			mb(105,1,0,20,'rotationz','Expo')
			for i = 106,108,2 do
				mb(i,1,0,-20,'rotationz','Expo')
				mb(i+1,1,0,20,'rotationz','Expo')
				
				mb(i,1,100,130,'zoom','Cubic')
				mb(i+1,1,100,130,'zoom','Cubic')
			end
			
			me(111,1,99.9,0,'reverse','len',outExpo,nil,8)
			mb(111,1,0,-150,'tinyy','Cubic')
			mb(111,1,0,-50,'tinyx','Cubic')	
			
			mb(113,1,0,30,'rotationy','Expo')
			for i = 114,116,2 do
				mb(i,1,0,-30,'rotationy','Expo')
				mb(i+1,1,0,30,'rotationy','Expo')
				
				mb(i,1,100,130,'zoomy','Cubic')
				mb(i+1,1,100,130,'zoomx','Cubic')
			end			
			
			me(119,1,0,99.9,'reverse','len',outExpo,nil,8)
			mb(119,1,0,-150,'tinyy','Cubic')
			mb(119,1,0,-50,'tinyx','Cubic')	
			
			mb(121,1,0,-30,'rotationy','Expo')
			for i = 122,124,2 do
				mb(i,1,0,30,'rotationy','Expo')
				mb(i+1,1,0,-30,'rotationy','Expo')
				
				mb(i,1,100,130,'zoomy','Cubic')
				mb(i+1,1,100,130,'zoomx','Cubic')
			end			
			
			trd_swaps(129,4,'invert',1)
			trd_swaps(137,4,'flip',6)
			trd_swaps(145,4,'invert',2)
			trd_swaps(153,2,'flip',4)
			
			me(127,1,99.9,0,'reverse','len',outExpo,nil,8)
			mb(127,1,0,-150,'tinyy','Cubic')
			mb(127,1,0,-50,'tinyx','Cubic')	
			
			--this is where the funny begins
			me(129,4.5,100,500,'zoomx','len',linear)
			me(129,4.5,100,80,'zoomy','len',linear)
			me(129,4.5,0,20,'rotationx','len',linear)
			
			me(133.5,1,500,100,'zoomx','len',outExpo)
			me(133.5,1,80,100,'zoomy','len',outExpo)
			me(133.5,1,20,0,'rotationx','len',outExpo)		

			me(135,1,0,99.9,'reverse','len',outExpo,nil,8)
			mb(135,1,0,-150,'tinyy','Cubic')
			mb(135,1,0,-50,'tinyx','Cubic')				
			
			me(137,4.5,100,500,'zoomx','len',linear)
			me(137,4.5,100,80,'zoomy','len',linear)
			me(137,4.5,0,20,'rotationx','len',linear)
			
			me(141.5,1,500,100,'zoomx','len',outExpo)
			me(141.5,1,80,100,'zoomy','len',outExpo)
			me(141.5,1,20,0,'rotationx','len',outExpo)	

			me(143,1,99.9,0,'reverse','len',outExpo,nil,8)
			mb(143,1,0,-150,'tinyy','Cubic')
			mb(143,1,0,-50,'tinyx','Cubic')				
			
			me(145,4.5,100,500,'zoomy','len',linear)
			me(145,4.5,100,80,'zoomx','len',linear)
			me(145,4.5,0,20,'rotationx','len',linear)
			
			me(149.5,1,500,100,'zoomy','len',outExpo)
			me(149.5,1,80,100,'zoomx','len',outExpo)
			me(149.5,1,20,0,'rotationx','len',outExpo)
			
			me(151,1,0,99.9,'reverse','len',outExpo,nil,8)
			mb(151,1,0,-150,'tinyy','Cubic')
			mb(151,1,0,-50,'tinyx','Cubic')
			
			me(153,2.5,100,500,'zoomy','len',linear)
			me(153,2.5,100,80,'zoomx','len',linear)
			me(153,2.5,0,20,'rotationx','len',linear)
			
			me(155.5,1,500,100,'zoomy','len',outExpo)
			me(155.5,1,80,100,'zoomx','len',outExpo)
			me(155.5,1,20,0,'rotationx','len',outExpo)
			
			me(159,1,99.9,0,'reverse','len',outExpo,nil,8)
			mb(159,1,0,-150,'tinyy','Cubic')
			mb(159,1,0,-50,'tinyx','Cubic')
			
			
			mb(156,1,0,-30,'rotationy','Expo')
			mb(157,1,0,30,'rotationy','Expo')
			
			--ok
			me(159,1,100,0,'zoom','len',inExpo)
			me(160,1,0,100,'zoom','len',outExpo)
			
			--i accidently created the effect from me & u without knowing it
			m(160,224,'*-1 -98% drawsizeback,*-1 halgun,*-1 300% drunkz,*-1 -300% drunk,*-1 950% drunkoffset,*-1 250% drunkzspeed,*-1 250% drunkspeed,*-1 90% rotationx,*-1 -157% confusionxoffset,*-1 200% drawsize, *-1 100% sudden, *-1 300% suddenoffset, *-1 98% dark,*-1 90% hideholds','end') --hi hello
			for i = 0,30 do
				local r = 360/30
				local c = -628/30
				me(192.5+i,1,r*i,r*(i+1),'rotationy','len',outBack)
				me(192.5+i,1,c*i,c*(i+1),'confusionzoffset','len',outBack)			
			end
			for i = 0,23 do
				me(192.5+i,1,-200,0,'tiny','len',outExpo)
			end
			for i = 0,7 do
				me(216+i,1,130,100,'zoom','len',outExpo)
			end
			
			me(220,4,90,0,'rotationx','len',inCubic)
			me(220,4,-157,0,'confusionxoffset','len',inCubic)
			me(220,4,300,0,'drunk','len',inExpo)
			me(220,4,-300,0,'drunkz','len',inExpo)
			me(222.5,1,0,0,'rotationy','len',linear)
			me(222.5,1,0,0,'confusionzoffset','len',linear)
			
			--EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE
			me(224,248,0,-80,'rotationx','end',linear)
			for i = 224,250,2 do
				me(i,1,0,20,'rotationz','len',outExpo)
				me(i,1,0,20,'rotationy','len',outExpo)
				me(i,1,0,50,'skewx','len',outExpo)
				me(i+1,1,0,-20,'rotationz','len',outExpo)
				me(i+1,1,0,-20,'rotationy','len',outExpo)
				me(i+1,1,0,-50,'skewx','len',outExpo)
				
				me(i,1,-300,0,'tiny0','len',inSine)
				me(i,1,-300,0,'tiny2','len',inSine)
				me(i,1,100,0,'tiny1','len',inSine)
				me(i,1,100,0,'tiny3','len',inSine)
				me(i+1,1,-300,0,'tiny1','len',inSine)
				me(i+1,1,-300,0,'tiny3','len',inSine)
				me(i+1,1,100,0,'tiny0','len',inSine)
				me(i+1,1,100,0,'tiny2','len',inSine)
			end
			for i = 224,251 do
				me(i,1,100,50,'brake','len',outCubic)
				me(i,1,120,100,'zoomy','len',outCubic)
				me(i,1,100,120,'zoomx','len',inCubic)
				--me(i,1,-200,0,'tiny','len',outCubic)
				me(i,1,-1000,0,'tinyz','len',outCubic)
			end
			for i = 224,238,2 do
				me(i,1,10,0,'dizzy','len',inCubic)
				me(i+1,1,-10,0,'dizzy','len',inCubic)
			end
			m(240,252,'*-1 0.1% bumpyperiod','end')
			for i = 240,250,2 do
				me(i,1,300,0,'bumpy','len',inCubic)
				me(i+1,1,-300,0,'bumpy','len',inCubic)
			end
			for i = 248,250,2 do
				me(i,1,-80,120,'rotationx','len',outExpo)
				me(i+1,1,-120,80,'rotationx','len',outExpo)
			end
			
			me(252,1,80,0,'rotationx','len',outExpo)
			me(252,1,-20,0,'rotationz','len',outExpo)
			me(252,1,-20,0,'rotationy','len',outExpo)
			me(252,1,-50,0,'skewx','len',outExpo)
			
			--are you shitting in my asshole			
			for i = 252, 254, 2 do
				mb(i,1,0,-400,'drunkz','Expo')
				mb(i,1,0,-20,'invert','Expo')
				mb(i+1,1,0,400,'drunkz','Expo')
				mb(i,1,0,20,'invert','Expo')
			end
			
			me(255,1,100,50,'zoom','len',outExpo)
			me(256,1,50,100,'zoom','len',outExpo)
			
			trd_swaps(257,4,'invert',1)
			trd_swaps(265,4,'flip',5)
			trd_swaps(273,4,'flip',2)
			trd_swaps(281,2,'invert',4)
			
			trd_swaps(289,4,'invert',1)
			trd_swaps(297,4,'flip',6)
			trd_swaps(305,4,'flip',2)
			trd_swaps(313,2,'invert',3)				

			me(263,1,0,99.9,'reverse','len',outExpo,nil,8)
			mb(263,1,0,-150,'tinyy','Cubic')
			mb(263,1,0,-50,'tinyx','Cubic')		
			
			me(271,1,99.9,0,'reverse','len',outExpo,nil,8)
			mb(271,1,0,-150,'tinyy','Cubic')
			mb(271,1,0,-50,'tinyx','Cubic')				
			
			me(279,1,0,99.9,'reverse','len',outExpo,nil,8)
			mb(279,1,0,-150,'tinyy','Cubic')
			mb(279,1,0,-50,'tinyx','Cubic')
			
			me(287,1,99.9,0,'reverse','len',outExpo,nil,8)
			mb(287,1,0,-150,'tinyy','Cubic')
			mb(287,1,0,-50,'tinyx','Cubic')
			
			
			me(295,1,0,99.9,'reverse','len',outExpo,nil,8)
			mb(295,1,0,-150,'tinyy','Cubic')
			mb(295,1,0,-50,'tinyx','Cubic')		
			
			me(303,1,99.9,0,'reverse','len',outExpo,nil,8)
			mb(303,1,0,-150,'tinyy','Cubic')
			mb(303,1,0,-50,'tinyx','Cubic')				
			
			me(311,1,0,99.9,'reverse','len',outExpo,nil,2)
			mb(311,1,0,-150,'tinyy','Cubic')
			mb(311,1,0,-50,'tinyx','Cubic')
			
			me(319,1,99.9,0,'reverse','len',outExpo)
			mb(319,1,0,-150,'tinyy','Cubic')
			mb(319,1,0,-50,'tinyx','Cubic')
			
			me(257,261.5,0,90,'rotationy','end',outSine)
			me(261.5,1,90,0,'rotationy','len',outExpo)
			
			me(265,269.5,0,-90,'rotationy','end',outSine)
			me(269.5,1,-90,0,'rotationy','len',outExpo)
			
			me(273,277.5,-720,0,'rotationx','end',inOutSine)
			
			me(281,283.5,720,0,'rotationx','end',inOutSine)			
			
			mb(284,1,0,30,'rotationy','Expo')
			mb(285,1,0,-30,'rotationy','Expo')
			
			for i = 257,273,8 do
				for b = 0,4.5,0.5 do
					me(i+b,1,-200,0,'tiny','len',outCubic)
				end
			end
			for b = 0,2.5,0.5 do
				me(281+b,1,-200,0,'tiny','len',outCubic)
			end
			
			me(288,1,0,90,'rotationx','len',outExpo,nil,4.5)
			me(288,1,0,-157,'confusionxoffset','len',outExpo,nil,4.5)
			me(288,1,0,-100,'movey','len',outExpo,nil,4.5)
			me(288,1,0,50,'boost','len',outExpo,nil,4.5)
			me(288,1,0,80,'tinyx','len',outExpo,nil,4.5)
			me(288,1,0,80,'tinyz','len',outExpo,nil,4.5)
			me(288,1,0,20,'flip','len',outExpo,nil,4.5)
			me(288,1,0,95,'dark','len',outExpo,nil,4.5)
			me(288,1,90,100,'hidemines','len',outExpo,nil,4.5)
			mb(288,1,0,-1000,'parabolaz','Cubic')
			
			for i = 289,293 do
				mb(i,0.5,0,1000,'parabolaz','Cubic')
				mb(i+0.5,0.5,0,-1000,'parabolaz','Cubic')
			end
			
			me(293.5,1,90,0,'rotationx','len',outExpo)
			me(293.5,1,-157,0,'confusionxoffset','len',outExpo)
			me(293.5,1,-100,0,'movey','len',outExpo)
			me(293.5,1,50,0,'boost','len',outExpo)
			me(293.5,1,80,0,'tinyx','len',outExpo)
			me(293.5,1,80,0,'tinyz','len',outExpo)
			me(293.5,1,20,0,'flip','len',outExpo)
			me(293.5,1,95,0,'dark','len',outExpo)
			me(293.5,1,100,90,'hidemines','len',outExpo)
			
			m(297,302,'*-1 20% arrowpath,*-1 300% arrowpathdrawsizeback,*-1 300% arrowpathdrawsize,*-1 1% squarezperiod','end')
			for i = 0,4,0.5 do  -- Cod  eing
				local m = -160/9
				local c = 600/9	
				local f = -50/9
				local t = 100/9
				local a = -180/9
				me(297+i,1,m*(i+1),m*(i+1),'rotationx','len',linear)
				me(297+i,1,c*(i+1),c*(i+1),'squarez','len',linear,1)			
				me(297+i,1,-c*(i+1)*3.5,-c*(i+1)*3.5,'squarez','len',linear,2)			
				me(297+i,1,f*(i+1),f*(i+1),'flip','len',linear)		
				me(297+i,1,t*(i+1),t*(i+1),'tiny','len',linear)		
				me(297+i,1,a*(i+1),a*(i+1),'attenuatex','len',linear)					
				me(i,0.5,100,50,'brake','len',outCubic)				
			end
			
			me(301.5,1,-150,0,'rotationx','len',outExpo)
			me(301.5,1,600,0,'squarez','len',outExpo,1)
			me(301.5,1,-600*3.5,0,'squarez','len',outExpo,2)
			me(301.5,1,-50,0,'flip','len',outExpo)
			me(301.5,1,100,0,'tiny','len',outExpo)
			me(301.5,1,-180,0,'attenuatex','len',outExpo)			
			
			me(304,1,0,100,'hidden','len',outExpo,nil,4.5)
			me(304,1,0,70,'brake','len',outExpo,nil,4.5) --fuck you peeesh
			me(305,4.5,100,250,'zoomy','len',inSine)
			me(305,4.5,0,40,'rotationx','len',inSine)
			
			me(312,1,2,5,'xmod','len',outSine,nil,3.5)
			me(313,2.5,100,50,'reverse','len',outSine)
			me(313,2.5,0,50,'flip','len',outSine)
			me(313,2.5,0,-800,'tiny','len',outSine)
			
			me(315.5,1,-800,0,'tiny','len',outExpo)
			me(315.5,1,50,0,'flip','len',outExpo)
			me(315.5,1,50,0,'reverse','len',outExpo)
			me(315.5,1,5,2,'xmod','len',outSine)			
			
			mb(316,1,0,-30,'rotationy','Expo')
			mb(317,1,0,30,'rotationy','Expo')
			
			me(315.5,3.5,-314/2,-314/2,'confusionzoffset0','len',linear)
			me(315.5,3.5,-314/2,-314/2,'confusionzoffset3','len',linear)
			me(315.5,3.5,314/2,314/2,'confusionzoffset1','len',linear)
			me(315.5,3.5,314/2,314/2,'confusionzoffset2','len',linear)
			me(315.5,3.5,100,100,'invert','len',linear) --funny house
			
			mb(319,1,0,-20,'reverse','Expo')
			me(319,0.5,100,0,'invert','len',outExpo)
			me(319,0.5,-314/2,0,'confusionzoffset0','len',outExpo)
			me(319,0.5,-314/2,0,'confusionzoffset3','len',outExpo)
			me(319,0.5,314/2,0,'confusionzoffset1','len',outExpo)
			me(319,0.5,314/2,0,'confusionzoffset2','len',outExpo)
			
			me(320,1.5,-1000,0,'tiny','len',outCubic)
			me(320,1,0,100,'centered','len',outCubic,nil,999)
			m(320,999,'*-1 0.1% tipsyspeed,*-1 0.1% drunkspeed,*-1 hidemines,*1 disablemines','end')
			me(320,1,0,500,'tipsy','len',outCubic,1,999)
			me(320,1,0,-500,'tipsy','len',outCubic,2,999)
			me(320,1,0,500,'drunk','len',outCubic,2,999)
			me(320,1,0,-500,'drunk','len',outCubic,1,999)
			me(320,12,100,0,'zoom','len',inSine,nil,999)
			me(320,12,0,180,'rotationz','len',inSine,nil,999)
			
			for c = 0,3 do
				local wenis = (c+2)*2
				me(320,12,0,300*randomXD(wenis)*c,'confusionzoffset'..c,'len',inSine)
				me(320,12,0,300*randomXD(wenis)*c,'confusionyoffset'..c,'len',inSine)
				me(320,12,0,300*randomXD(wenis)*c,'confusionxoffset'..c,'len',inSine)
			end
			
			--funny visual
			function trd_flash(beat,len,which)
				if which == 1 then --left
					mm(beat,function()
						trd_l:diffuse(1,0.5,0.5,0)
						trd_r:diffuse(0.5,0.5,1,0)
					end)
					for i = beat,beat+len do
						me(i,0.5,1,0,function(a)
							trd_l:diffusealpha(a)
						end,'len',linear)
						me(i+0.5,0.5,1,0,function(a)
							trd_r:diffusealpha(a)
						end,'len',linear)
					end
				elseif which == 2 then --right
					mm(beat,function()
						trd_l:diffuse(0.5,0.5,1,0)
						trd_r:diffuse(1,0.5,0.5,0)
					end)
					for i = beat,beat+len do
						me(i,0.5,1,0,function(a)
							trd_r:diffusealpha(a)
						end,'len',linear)
						me(i+0.5,0.5,1,0,function(a)
							trd_l:diffusealpha(a)
						end,'len',linear)
					end
				elseif which == 3 then --up
					mm(beat,function()
						trd_t:diffuse(1,0.5,0.5,0)
						trd_b:diffuse(0.5,0.5,1,0)
					end)
					for i = beat,beat+len do
						me(i,0.5,1,0,function(a)
							trd_t:diffusealpha(a)
						end,'len',linear)
						me(i+0.5,0.5,1,0,function(a)
							trd_b:diffusealpha(a)
						end,'len',linear)
					end
				else --down
					mm(beat,function()
						trd_t:diffuse(0.5,0.5,1,0)
						trd_b:diffuse(1,0.5,0.5,0)
					end)
					for i = beat,beat+len do
						me(i,0.5,1,0,function(a)
							trd_b:diffusealpha(a)
						end,'len',linear)
						me(i+0.5,0.5,1,0,function(a)
							trd_t:diffusealpha(a)
						end,'len',linear)
					end
				end
			end
			trd_flash(97,4,1)
			trd_flash(105,4,2)	
			trd_flash(113,4,3)
			trd_flash(121,2,4)
			
			trd_flash(129,4,2)
			trd_flash(137,4,1)
			trd_flash(145,4,4)
			trd_flash(153,2,3)
			
			trd_flash(257,4,1)
			trd_flash(265,4,2)	
			trd_flash(273,4,3)
			trd_flash(281,2,4)
			
			trd_flash(289,4,2)
			trd_flash(297,4,1)
			trd_flash(305,4,4)
			trd_flash(313,2,3)
			
			me(320,1,1,0,function(a)
				trd_m:diffusealpha(a)
			end,'len',linear)
---------------------------------------------------------------------------------------
----------------------Sort the actions table-------------------------------------------
---------------------------------------------------------------------------------------
			
			function modtable_compare(a,b)
				return a[1] < b[1]
			end
			
			if table.getn(mod_actions) > 1 then
				table.sort(mod_actions, modtable_compare)
			end
			
			self:queuecommand('Update');
			
		end"
		
		UpdateCommand="%function(self)
			local beat = GAMESTATE:GetSongBeat()
			
			if beat>=0 and not checked then
					local ThingsToGrab = {'BPMDisplay','LifeFrame','ScoreFrame','Lyrics','SongBackground','SongForeground','Overlay','Underlay'}
					local ThingsToHide = {'BPMDisplay','LifeFrame','ScoreFrame','Overlay','Underlay'}
					for pn=1,2 do
						_G['P'..pn] = SCREENMAN:GetTopScreen():GetChild('PlayerP'..pn) or nil;
						if _G['P'..pn] then
							table.insert(mod_plr, _G['P'..pn])
							_G['jud'..pn]=_G['P'..pn]:GetChild('Judgment');
							_G['com'..pn]=_G['P'..pn]:GetChild('Combo');
							_G['jud'..pn]:hidden(1)
							_G['com'..pn]:hidden(1)
						end
						table.insert(ThingsToGrab,'LifeP'..pn); table.insert(ThingsToGrab,'ScoreP'..pn);
						table.insert(ThingsToHide,'LifeP'..pn); table.insert(ThingsToHide,'ScoreP'..pn);
					end	
					for i,v in ipairs(ThingsToGrab) do _G[v] = SCREENMAN:GetTopScreen():GetChild(v) or nil end	
					for i,v in ipairs(ThingsToHide) do if _G[v] then _G[v]:hidden(1) end end
				checked = true;
			end
			mod_curtime = GAMESTATE:GetSongTime()
			mod_lasttime = 0
			local deltatime = mod_curtime - mod_lasttime
			local deltatime = mod_curtime - mod_lasttime
			
			if P1 then P1:NoClearSplines(true) end
			if P2 then P2:NoClearSplines(true) end
			
			--p3/4/etc disabling judgment/combo stuff
			local P3 = SCREENMAN:GetTopScreen():GetChild('PlayerP3')
			local P4 = SCREENMAN:GetTopScreen():GetChild('PlayerP4')
			local P5 = SCREENMAN:GetTopScreen():GetChild('PlayerP5')
			local P6 = SCREENMAN:GetTopScreen():GetChild('PlayerP6')
			local P7 = SCREENMAN:GetTopScreen():GetChild('PlayerP7')
			local P8 = SCREENMAN:GetTopScreen():GetChild('PlayerP8')
			if P3 and P4 then --add more if necessary
				for pn=3,8 do --also change this with player count
					_G['P'..pn] = SCREENMAN:GetTopScreen():GetChild('PlayerP'..pn) or nil;
					if _G['P'..pn] then
						table.insert(mod_plr, _G['P'..pn])
						_G['jud'..pn]=_G['P'..pn]:GetChild('Judgment');
						_G['com'..pn]=_G['P'..pn]:GetChild('Combo');
						_G['jud'..pn]:hidden(1)
						_G['com'..pn]:hidden(1)
					end
				end
			end
			
---------------------------------------------------------------------------------------
----------------------Begin table handlers---------------------------------------------
---------------------------------------------------------------------------------------
			
			disable = false;
			if disable ~= true and checked then
				
				-----------------------
				-- Player mod resets --
				-----------------------
				if beat > mod_firstSeenBeat+0.1 then -- performance coding!! --
					for i=1,2 do
						GAMESTATE:ApplyModifiers('clearall',i)
						if _G['init_modsp'..i] then 
							GAMESTATE:ApplyModifiers(_G['init_modsp'..i],i)
						end
					end
				end
				
				------------------------------------------------------------------------------
				-- custom mod reader by TaroNuke edited by WinDEU and re-stolen by TaroNuke --
				------------------------------------------------------------------------------
				if beat > mod_firstSeenBeat+0.1 then -- performance coding!! --
					for i,v in pairs(mods) do
						if v and table.getn(v) > 3 and v[1] and v[2] and v[3] and v[4] then
							if beat >=v[1] then
								if (v[4] == 'len' and beat <=v[1]+v[2]) or (v[4] == 'end' and beat <=v[2]) then
									if table.getn(v) == 5 then
										GAMESTATE:ApplyModifiers(v[3],v[5]);
									else
										GAMESTATE:ApplyModifiers(v[3]);
									end
								end
							end
						else
							v[1] = 0;
							v[2] = 0;
							v[3] = '';
							v[4] = 'error';
							SCREENMAN:SystemMessage('Bad mod in beat-based table (line '..i..')');
						end
					end
				end
				
				-----------------------------------------------------------------------------------------------------
				-- WinDEU's time-based len/end version of the #swag custom mod reader #teamproofofconcept (c) 2015 --
				-----------------------------------------------------------------------------------------------------
				if beat > mod_firstSeenBeat+0.1 then -- performance coding!! --
					for i,v in pairs(mods2) do
						if v and table.getn(v) > 3 and v[1] and v[2] and v[3] and v[4] then
							if mod_time >=v[1] then
								if (v[4] == 'len' and mod_time <=v[1]+v[2]) or (v[4] == 'end' and mod_time <=v[2]) then
									if table.getn(v) == 5 then
										GAMESTATE:ApplyModifiers(v[3],v[5]);
									else
										GAMESTATE:ApplyModifiers(v[3]);
									end
								end
							end
						else
							v[1] = 0;
							v[2] = 0;
							v[3] = 'error';
							v[4] = 'error';
							SCREENMAN:SystemMessage('Bad mod in time-based table (line '..i..')');
						end
					end
				end
				
				---------------------------------------
				-- Ease table (includes func_ease) --
				---------------------------------------
				if beat > mod_firstSeenBeat+0.1 then
				for i,v in pairs(mods_ease) do
		            if v and table.getn(v) > 6 and v[1] and v[2] and v[3] and v[4] and v[5] and v[6] and v[7] then
		                if beat >=v[1] then
		                    if (v[6] == 'len' and beat <=v[1]+v[2]) or (v[6] == 'end' and beat <=v[2]) then
		                        local strength = v[7](beat - v[1], v[3], v[4] - v[3], v[6] == 'end' and v[2] - v[1] or v[2], v[10], v[11])
		                        if type(v[5]) == 'string' then
		                        	local modstr = v[5] == 'xmod' and strength..'x' or (v[5] == 'cmod' and 'C'..strength or strength..' '..v[5])
		                        	GAMESTATE:ApplyModifiers('*9999 '..modstr,v[8]);
		                        elseif type(v[5]) == 'function' then
		                        	v[5](strength)
		                        end
		                    elseif (v[9] and ((v[6] == 'len' and beat <=v[1]+v[2]+v[9]) or (v[6] == 'end' and beat <=v[9]))) then
		                    	if type(v[5]) == 'string' then
		                        	local modstr = v[5] == 'xmod' and v[4]..'x' or (v[5] == 'cmod' and 'C'..v[4] or v[4]..' '..v[5])
		                        	GAMESTATE:ApplyModifiers('*9999 '..modstr,v[8]);
		                        elseif type(v[5]) == 'function' then
		                        	v[5](v[4])
		                        end
		                    end
		                end
		            else
		                SCREENMAN:SystemMessage('Ease Error! (line '..i..' | beat: '.. v[1] .. ' | mod: '.. v[5] ..')');
		            end
		        end
				end
				---------------------
				-- Perframe reader --
				---------------------
				if beat > mod_firstSeenBeat+0.1 then
				if table.getn(mod_perframes)>0 then
		            for i=1,table.getn(mod_perframes) do
		                local a = mod_perframes[i]
		                if beat > a[1] and beat < a[2] then
		                    a[3](beat,deltatime);
		                end
		            end
		        end
				end
				---------------------------------------
				-- Actions table --
				---------------------------------------
				if beat > mod_firstSeenBeat+0.1 then -- performance coding!! --
					while curaction<=table.getn(mod_actions) and GAMESTATE:GetSongBeat()>=mod_actions[curaction][1] do
						if mod_actions[curaction][3] or GAMESTATE:GetSongBeat() < mod_actions[curaction][1]+2 then
							if type(mod_actions[curaction][2]) == 'function' then
								mod_actions[curaction][2]()
							elseif type(mod_actions[curaction][2]) == 'string' then
								MESSAGEMAN:Broadcast(mod_actions[curaction][2]);
							end
						end
						curaction = curaction+1;
					end
				end
				
			end
			
			mod_lasttime = mod_curtime
			--self:sleep(0.02);
			--self:queuecommand('Update');
			self:hidden(0);
			self:zoom(0);
			self:luaeffect('Update');

---------------------------------------------------------------------------------------
----------------------END DON'T TOUCH IT KIDDO-----------------------------------------
---------------------------------------------------------------------------------------
			
		end"
		
	/>
	
	<ZZLAER Type="ActorFrame" InitCommand="%function(self) judc = self end"><children>
	<LAER Type="ActorProxy" InitCommand="%function(self) jud1p = self end"
	GetProxyMessageCommand="%function(self) if P1 then self:SetTarget(P1:GetChild('Judgment')) end end"/>
	<LAER Type="ActorProxy" InitCommand="%function(self) jud2p = self end"
	GetProxyMessageCommand="%function(self) if P2 then self:SetTarget(P2:GetChild('Judgment')) end end"/>
	</children></ZZLAER>
	<ZZLAER Type="ActorFrame" InitCommand="%function(self) comc = self end"><children>
	<LAER Type="ActorProxy" InitCommand="%function(self) com1p = self end"
	GetProxyMessageCommand="%function(self) if P1 then self:SetTarget(P1:GetChild('Combo')) end end"/>
	<LAER Type="ActorProxy" InitCommand="%function(self) com2p = self end"
	GetProxyMessageCommand="%function(self) if P2 then self:SetTarget(P2:GetChild('Combo')) end end"/>
	</children></ZZLAER>
	
	<!--This is for the time based mod reader-->
	<BitmapText
		Font="Common Normal"
		Text="test"
		OnCommand="x,SCREEN_CENTER_X;y,SCREEN_CENTER_Y;effectclock,music;playcommand,SetTime;hidden,1"
		SetTimeCommand="%function(self) self:settext(self:GetSecsIntoEffect()); mod_time = tonumber(self:GetText()); self:sleep(0.02); self:queuecommand('SetTime'); end"
	/>
	
</children></ActorFrame></children></ActorFrame>