<ActorFrame
InitCommand="%function(self)

	nitg_version = FUCK_EXE and tonumber(GAMESTATE:GetVersionDate()) >= 20180617 --NotITG version number to check for, v3 by default
	
	if not nitg_version then
		SCREENMAN:SystemMessage('Outdated version of NotITG detected, mods will not work');
	end
	
	songName = GAMESTATE:GetCurrentSong():GetSongDir();
	
	m_bl = 60/145 --use this to define length of a beat for use in the rest of the song
	sw = SCREEN_WIDTH
	sh = SCREEN_HEIGHT --shortcuts
	scx = SCREEN_CENTER_X
	scy = SCREEN_CENTER_Y
	
	function Plr(pn)
		return _G['P'..pn]
	end
	
	cg_slumpage = false
	
	if GAMESTATE:GetCurrentSteps(0):GetDifficulty()==5 or GAMESTATE:GetCurrentSteps(1):GetDifficulty()==5 then
		cg_slumpage = true
	end
end"
><children><ActorFrame Condition="nitg_version"
OnCommand="%function(self)
	nvidia = false
	alphamult = 1
	if string.find(string.lower(PREFSMAN:GetPreference('LastSeenVideoDriver')), 'nvidia') or string.find(string.lower(DISPLAY:GetVendor()),'nvidia') then
		Trace('NVidia graphics driver detected.')
		Trace('AFT multiplier set to 0.9')
		nvidia = true
		alphamult = 0.9
	end
	if not string.find(string.lower(PREFSMAN:GetPreference('VideoRenderers')), 'opengl')
	or string.find(string.lower(PREFSMAN:GetPreference('VideoRenderers')), 'd3d')
	and string.find(string.lower(PREFSMAN:GetPreference('VideoRenderers')), 'opengl') 
	and string.find(string.lower(PREFSMAN:GetPreference('VideoRenderers')), 'd3d') < 
	string.find(string.lower(PREFSMAN:GetPreference('VideoRenderers')), 'opengl') then
		SCREENMAN:SystemMessage('D3D Video Renderer detected. Expect textures to fail.');
	end
end"
><children>

	<Layer
		Type="Quad"
		InitCommand="hidden,1"
		OnCommand="sleep,1000"
	/>
	
	<Layer File="modhelpers" />
	<Layer File="easing" />	
	<Layer File="spellcards" />	
	
	<Layer File="c2l/good" />
	<Layer File="c2l/shopping_cart" />
	<Layer File="c2l/donk" />
	<Layer File="c2l/shitdick4000" />
	<Layer File="c2l/notebadta" />
	
	<Layer
		Type="Quad"
		OnCommand="hidden,1"
		InitCommand="%function(self)
		
			checked = false;
		
			---------------------------------------------------------
			---------DOCUMENTATION-----------------------------------
			---------------------------------------------------------
			
			--function perframe( beat, endBeat )
				--return true if the current beat is between 'beat' and 'endBeat'
			
			--function mod_shader(beat,key,which)
				--turn on shader key at specified beat (up to 10 keys available, defined by 'which' = 0-9
				
			--function mod_insert(beat,len,mod,len_or_end,pn)
				--insert mod into beat mods table
			--function mod_insert2(time,len,mod,len_or_end,pn)
				--insert mod into time mods table
			--function mod_ease(beat, len, start_strength, end_strength, mod, len_or_end, ease_type, pn, sustain, opt1, opt2)
				--insert mod into ease mods table
			--function mod_perframe(start, end, function(beat, deltatime))
				--insert function into perframe reader
				
			--function mod_message(beat,msg,persistent)
				--insert something into the actions table.
				--msg can also be a function. If string, a message gets broadcast at that beat
				--if 'persistent' is true, message will run even if editor starts at a beat past it
				
			--function mod_blacklist(t,n)
				--check if number n occurs in table t
				--useful for doing 'every beat EXCEPT the contents of t'
				
			--function simple_m0d(beat,strength,mult,mod)
			--function simple_m0d2(beat,strength,mult,mod,pn)
			--function simple_m0d3(beat,strength,duration,bpm,mod,pn)
				--activate mods at specific beat but also deactivate them
				
			--function mod_wiggle(beat,num,div,amt,speed,mod,pn,first)
				--alternates a mod back and forth before resetting to 0
				
			--function mod_spring(beat,strength,num,mod,pn)
				--like mod_wiggle, but springier
			
			--function mod_springt(time,strength,dur,mod,pn)
				--time-based per-frame alternating mod that decreases based on how much time is left.
					--think doorstopper
			
			--function mod_springt2(time,strength,dur,mod,pn)
				--time-based per-frame alternating mod
			
			--function mod_spring_adjustable(beat,strength,num,period,mod,pn, first)
				--it's not very good
			
			--function mod_beat(beat,strength,pn)
				--turns on beat for the beat specified, at the desired strength	
			
			--function switcheroo_add(beat,which,speed,len,pn)
				--adds a column swap at the desired beat
			--[[	switcheroos = {normal = {0,0}, ldur = {0,0}, reset = {0,0},
					flip = {100,0}, rudl = {100,0}, invert = {0,100}, dlru = {0,100},
					ludr = {25,-75}, rdul = {75,75}, drlu = {25,125}, ulrd = {75,-125}, urld = {100,-100}}
			]]
			
			--function mod_sugarkiller(beat,duration,speed,minstealth,maxstealth,pn)
				--portable version of the effect from sugarkill X
			
			--NEW**
			--function sugaroo_add(beat,len,speed,stealthvalmain,stealthvalsec,pn)
				--a version of mod_sugarkiller stoken from Daikyi that actually works !
				
			--function mod_bounce(beat,length,start,apex,mod,ease_type,pn)
			--function func_bounce(beat,length,start,apex,function,ease_type)
				--eases out from start to apex, then eases back in from apex to start
				--ease_type should be a string, i.e. 'Quad', 'Cubic', 'Circ'
			
			
			
			--function modulo(a, b)
				--returns the remainder when a is divided by b, works properly with negatives unlike math.mod
			
			--function randomXD(t)
				--returns a pseudo-random number between 0 and 1 seeded based on the given argument
				--returns 0.5 if t is 0 (useful sometimes!)
			
			--function hidecol(beat,len,col,which,pn)
				--stealth + dark + hidenoteflashes per column, insta-activate with normal modstrings
				
			--function hideease(beat,len,col,which,ease,sus,pn)
				--hidecol but with eases
				
			--function SpawnPlayers(beat,lower,upper,which,persist)
				--stolen from hal
				--lower/upper is player numbers
				--which: 'spawn'/'despawn'
				--persist should probably be true
			---------------------------------------------------------
			--------END DOCUMENTATION--------------------------------
			---------------------------------------------------------
			
			
			
			
			
			
			
			
			
			init_modsp1 = '';
			init_modsp2 = '';
			
			mod_plr = {};
			
			mod_firstSeenBeat = GAMESTATE:GetSongBeat(); --necessary to prevent long freezes
			
			
---------------------------------------------------------------------------------------
----------------------Begin tables 'n stuff--------------------------------------------
---------------------------------------------------------------------------------------

			--beat based mods
			--{beat_start, beat_end, mods, len_or_end, player_number}
			mods = {
				{0,9999,'*2 1.8x, *-1 overhead, *-1 approachtype, *-1 dizzyholds, *-1 stealthpastreceptors, *-1 modtimer','end'},
			}
			
			--beat-based ease mods
			--{beat_start, beat_end, mod_start, mod_end, mod/function, len_or_end, ease_type, player_number, sustainbeats, optional_param1, optional_param2}
			--valid ease types are:
				--linear
				--inQuad    outQuad    inOutQuad    outInQuad
				--inCubic   outCubic   inOutCubic   outInCubic
				--inQuart   outQuart   inOutQuart   outInQuart
				--inQuint   outQuint   inOutQuint   outInQuint
				--inSine    outSine    inOutSine    outInSine
				--inExpo    outExpo    inOutExpo    outInExpo
				--inCirc    outCirc    inOutCirc    outInCirc
				--inElastic outElastic inOutElastic outInElastic    --can take 2 optional parameters - amplitude & period
				--inBack    outBack    inOutBack    outInBack       --can take 1 optional parameter  - spring amount
				--inBounce  outBounce  inOutBounce  outInBounce
				
			mods_ease = {
				-- EXAMPLE TWEEN: from beat 0 to 4, make rotationz go from 360 to 0 with the inOutBack tween
				--{0, 4, 360, 0, 'rotationz', 'len', inOutBack},
				
				-- EXAMPLE TWEEN: from beat 4 to 8, rotate topscreen from 360 to 0 with the outBack tween
				--{4, 4, 360, 0, function(a) SCREENMAN:GetTopScreen():rotationz(a) end, 'len', outBack},
			}
			
			--time based mods
			mod_time = 0;
			--{time_start, time_end, mods, len_or_end, player_number}
			mods2 = {
			}
			
			-- you can now write perframe stuff without having to scroll down!
			-- {beat_start,beat_end,function(beat,deltatime)}
			mod_perframes = {
				--{18,24,function(beat,deltatime)
					-- do stuff every frame from beat 18-24
					-- print(beat,deltatime)
				--end},
			}
			
			--this is both a message broadcaster and a function runner
			--if you put {beat,'String'}, then 'String' is broadcast as a message on that beat
			--if you put {beat,function() somecode end}, then function() is run at that beat
			--see example on beat 0
			
			curaction = 1;
			--{beat,thing,persists}
			mod_actions = {
				{0,'GetProxy',true},
				{0,function()
					for pn=1,2 do
						local a = Plr(pn)
						if a then
							a:GetChild('Judgment'):hidden(1)
							a:GetChild('Combo'):hidden(1)
							a:SetFarDist(10000)
							a:GetChild('Combo'):sleep(9E9) -- help
							a:GetChild('Judgment'):sleep(9E9) -- help
							
							a:SetDrawByZPosition(true)
						end
					end
					
					for pn=1,2 do
						local d = 0.25; if pn == 2 then d = 0.75 end
						local e = 0.10; if pn == 2 then e = 0.90 end
						local b = _G['jud'..pn..'p']
						if b then
							b:hidden(0);
							b:basezoomx(0.8);
							b:basezoomy(0.8);
							b:x(SCREEN_WIDTH*d)
							b:y(SCREEN_HEIGHT*0.15)
						end
						local c = _G['com'..pn..'p']
						if c then
							c:hidden(0);
							c:basezoomx(0.8);
							c:basezoomy(0.8);
							c:x(SCREEN_WIDTH*e)
							c:y(SCREEN_HEIGHT*0.05) --????
						end
					end
					
					GAMESTATE:ForceSmoothLines(0);
				end,true},				
				{0,function()
					for pn = 1,4 do
						a = Plr(pn)
						a:SetInputPlayer(math.mod(pn-1,2))
					end
				end,true},
			}
			
---------------------------------------------------------------------------------------
--***              	   begin Real Shit          	    		                  ***--
---------------------------------------------------------------------------------------
			local me,mb,m,mm,mpf = mod_ease,mod_bounce,mod_insert,mod_message,mod_perframe
			
			m(0, 999, '*-1 200 zoomz, *-1 halgun, *-1 -98 drawsizeback, *-1 hidemines', 'end') -- :)
			
			-- this might be too obnoxious
			for i = 0, 63 do
				local curbg = modulo(i, 8)
				
				mm(i, function()
					for c = 0, 7 do
						_G['cg_itg'..c]:diffusealpha(0)
					end					
					_G['cg_itg'..curbg]:diffusealpha(1)
				end, false)
			end
			
			m(0, 64, '*-1 50 flip, *-1 150 drawsize', 'end')
			mm(0, function()
				for pn = 1,2 do
					Plr(pn):x(scx)
				end
				
				cg_sexgrid:diffusealpha(0)
			end, true)
			
			local cg_rotx = -90
			local cg_roty = 0
			local cg_rotz = 0
			local cg_rotmult = 0
			local cg_speed = 0.2
			
			local cg_pad = 100
			local cg_turn = 0
			
			for i = 0, 63 do
				me(i, 1, cg_turn, cg_turn,function(a) cg_turn = a end, 'len', linear)
				cg_turn = cg_turn + 175
			end
			
			mpf(0, 64, function(beat)				
				for pn = 1,2 do
					for c = 0, 1 do	-- jank dpad moment
						GAMESTATE:ApplyModifiers('*-1 '..cg_pad*math.sin(cg_turn+math.abs(c-1)*2/1.25) ..'% movex'..c, pn)
						GAMESTATE:ApplyModifiers('*-1 '..cg_pad*math.cos(cg_turn+math.abs(c-1)*2/1.25) ..'% movez'..c, pn)
					end
					for c = 2, 3 do
						GAMESTATE:ApplyModifiers('*-1 '..cg_pad*math.sin(cg_turn+c*2/1.25) ..'% movex'..c, pn)
						GAMESTATE:ApplyModifiers('*-1 '..cg_pad*math.cos(cg_turn+c*2/1.25) ..'% movez'..c, pn)
					end
					GAMESTATE:ApplyModifiers(rotateAndCounter(cg_rotx, cg_roty, cg_rotz, pn)) -- too lazy to unimplement this lol
					
					if beat >= 33 then
						cg_rotx = cg_rotmult*math.sin(beat*cg_speed)
						--cg_roty = cg_rotmult*math.cos(beat*cg_speed)
						cg_rotz = cg_rotmult*math.cos(beat*cg_speed)
					end
				end				
			end)
			
			m(0, 29.5, '*-1 100 wave', 'end')
			
			me(29.5, 3, 100, 0, 'wave', 'len', inOutExpo)
			me(29, 4, -90, 0, function(a) cg_rotx = a end, 'len', inOutExpo)
			
			mm(32, function()
				cg_triena:diffusealpha(0.8)
			end,true)
			mm(48, function()
				cg_triena:diffusealpha(0)
				
				if cg_slumpage then -- get it its because i did your mom last night xDDDDDD
					cg_gay:diffusealpha(0.8)
				else
					cg_chewin:diffusealpha(0.8)
				end
			end,true)
			
			for i, v in ipairs(good) do
				me(v[1], 2, -200, 0, 'tiny', 'len', outExpo)
				me(v[1], 2, 70, 0, 'brake', 'len', outCirc)
			end
			
			local cg_shitmult = 0
			mpf(60, 64,function(beat) -- lol
				GAMESTATE:ApplyModifiers('*-1 '..(cg_shitmult*math.random()*200)..' bumpyx')
				GAMESTATE:ApplyModifiers('*-1 '..(cg_shitmult*math.random()*200)..' bumpyxoffset')
				GAMESTATE:ApplyModifiers('*-1 '..(cg_shitmult*math.random()*200)..' bumpyxperiod')
				GAMESTATE:ApplyModifiers('*-1 '..(cg_shitmult*math.random()*200/5)..' bumpy')
				GAMESTATE:ApplyModifiers('*-1 '..(cg_shitmult*math.random()*200)..' bumpyoffset')
				GAMESTATE:ApplyModifiers('*-1 '..(cg_shitmult*math.random()*200)..' bumpyperiod')
			end)			
			
			me(60, 64, 0, 1, function(a) cg_shitmult = a end, 'end', outCubic)
			me(60, 4, 0, 200, 'longholds', 'len', outSine)
			
			me(32, 48, 0, 30, function(a) cg_rotmult = a end, 'end', inOutSine)
			me(60, 64, 30, 50, function(a) cg_rotmult = a end, 'end', inOutSine)
			me(48, 64, 0.2, 0.6, function(a) cg_speed = a end, 'end', inSine)
			
			me(56, 8, 100, 130, 'zoomy', 'len', inOutQuad)
			me(56, 8, 100, 150, 'zoomx', 'len', inOutQuad)
			
			me(56, 8, 100, 200, function(a) cg_pad = a end, 'len', inOutSine)
			me(60, 4, 0, 1, function(a) cg_whitetop:diffusealpha(a) end, 'len', inOutSine)
			
			-- shopping carts
			me(64, 1, 0, 0, function(a) cg_rotx = a end, 'len', linear)
			me(64, 1, 0, 0, function(a) cg_roty = a end, 'len', linear)
			me(64, 1, 0, 0, function(a) cg_rotz = a end, 'len', linear)
			mm(64, function() 
				cg_whitetop:diffusealpha(0) 
				cg_blacktop:diffusealpha(1) 
				
				for c = 0, 7 do
					_G['cg_itg'..c]:diffusealpha(0)
				end	
				
				cg_chewin:diffusealpha(0)
				cg_gay:diffusealpha(0)
				
				for pn = 1, 2 do
					local b = _G['jud'..pn..'p']				
					local c = _G['com'..pn..'p']
					b:hidden(1)
					c:hidden(1)
				end
			end, true)
			
			mm(66.5, function() cg_blacktop:diffusealpha(0) end, true)
			
			SpawnPlayers(64, 3, 4, 'spawn', true)
			
			m(64, 68, '*-1 100 stealth, *-1 100 dark, *-1 hidenoteflashes', 'end')
			m(64, 68, '*-1 80 zoom, *-1 -50 movey', 'end')
			m(64, 71, '*-1 2000 arrowpathsize, *-1 150 arrowpathdrawsize, *-1 150 arrowpathdrawsizeback', 'end')
			m(64, 200, '*-1 150 drawsize, *-1 95 sudden, *-1 300 suddenoffset', 'end')
			m(64, 68, '*-1 -400 movex', 'end', 1)
			m(64, 68, '*-1 400 movex', 'end', 4)
			mm(64, function()
				for pn = 1, 4 do
					Plr(pn):x(scx)
				end
				
				for pn = 1, 4 do				
					if _G['P'..pn] then
						for c = 0, 3 do							
							_G['P'..pn]:SetNumPathGradientPoints(c, 2)
							_G['P'..pn]:SetPathGradientPoint(0, c, -30)
							_G['P'..pn]:SetPathGradientPoint(1, c, 30)
						end
					end
				end
				
				for c = 0, 3 do
					for n = 0, 1 do
						P1:SetPathGradientColor(n, c, 238/255, 146/255, 151/255, 1)
						P2:SetPathGradientColor(n, c, 88/255, 218/255, 113/255, 1)
						P3:SetPathGradientColor(n, c, 88/255, 218/255, 113/255, 1)
						P4:SetPathGradientColor(n, c, 236/255, 239/255, 111/255, 1)
					end
				end
			end, true)
			
			me(66.5, 1.5, 0, 0, 'dark', 'len', linear, 2)
			me(66.5, 2, 50, 0, 'arrowpath', 'len', outExpo, 2)
			me(66.5, 2, -100, 0, 'tiny', 'len', outExpo, 2)
			me(66.5, 1.5, 0, 0, 'dark', 'len', linear, 3)
			me(66.5, 2, 50, 0, 'arrowpath', 'len', outExpo, 3)
			me(66.5, 2, -100, 0, 'tiny', 'len', outExpo, 3)
			
			me(67, 1, 0, 0, 'dark', 'len', linear, 1)
			me(67, 2, 50, 0, 'arrowpath', 'len', outExpo, 1)
			me(67, 2, -100, 0, 'tiny', 'len', outExpo, 1)
			
			me(67.5, 0.5, 0, 0, 'dark', 'len', linear, 4)
			me(67.5, 2, 50, 0, 'arrowpath', 'len', outExpo, 4)
			me(67.5, 2, -100, 0, 'tiny', 'len', outExpo, 4)
			
			mm(68, function()
				for pn = 1, 4 do				
					if _G['P'..pn] then
						for c = 0, 3 do
							for n = 0, 1 do
								_G['P'..pn]:SetPathGradientColor(n, c, 14/255, 20/255, 168/255, 1)
							end
						end
					end
				end
			end, true)
			me(68, 4, 100, 0, 'arrowpath', 'len', outSine)
			
			me(68, 4, 80, 100, 'zoom', 'len', inOutExpo)
			me(68, 4, -50, 0, 'movey', 'len', inOutExpo)
			me(68, 4, -400, 0, 'movex', 'len', inOutExpo, 1)
			me(68, 4, 400, 0, 'movex', 'len', inOutExpo, 4)
			
			me(68, 4, 0, 0.5, function(a) cg_black:cropleft(a) end, 'len', inOutCirc)
			me(68, 4, 0, 0.5, function(a) cg_black:cropright(a) end, 'len', inOutCirc)
			mm(72, function() cg_black:diffusealpha(0) cg_black:cropleft(0) cg_black:cropright(0) end, true)
			mm(68, function()  cg_sexgrid:diffusealpha(0.1) end, true)
			
			for pn = 1, 2 do
				me(68, 4, 0, -78, 'movez', 'len', inOutExpo, pn, 28) -- oddly specific
			end
			for pn = 3, 4 do
				me(68, 4, 0, 78, 'movez', 'len', inOutExpo, pn, 28)
			end
			
			local cg_rotx2 = 0
			local cg_roty2 = 0			
			
			local cg_stripeR = 248
			local cg_stripeG = 180
			local cg_stripeB = 0
			mpf(68, 200, function(beat)  -- auxvar abuse: it's more likely than you think.
				for pn = 1, 2 do
					GAMESTATE:ApplyModifiers(rotateAndCounter(cg_rotx, cg_roty, cg_rotz, pn), pn)
				end
				for pn = 3, 4 do
					GAMESTATE:ApplyModifiers(rotateAndCounter(cg_rotx2, cg_roty2, cg_rotz, pn), pn)
				end
				
				for i,v in ipairs({cg_stripetop, cg_dashtop1, cg_dashtop2, cg_stripebottom, cg_dashbottom1, cg_dashbottom2}) do -- three var func_ease when :(
					v:diffuse(cg_stripeR/255, cg_stripeG/255, cg_stripeB/255, 1)
				end
			end)
			me(68, 4, 360, 0, function(a) cg_roty = a end, 'len', inOutExpo)
			me(68, 4, 360, 0, function(a) cg_roty2 = a end, 'len', inOutExpo)
			me(68, 4, 0, -70, function(a) cg_rotx = a end, 'len', inOutExpo)
			me(68, 4, 0, -110, function(a) cg_rotx2 = a end, 'len', inOutExpo)
			
			mm(72, function()
				for pn = 1, 2 do
					local b = _G['jud'..pn..'p']				
					local c = _G['com'..pn..'p']
					b:hidden(0)
					c:hidden(0)
				end
			end, true)
			
			-- succ			
			me(64, 132, 0, 20, function(a)  cg_sexgrid:rotationz(a) end, 'end', linear)
			
			mm(0, function()
				cg_stripesettop:hidden(1)
				cg_stripesetbottom:hidden(1)
				cg_diamond:hidden(1)
				cg_circle:hidden(1)
			end, true)
			mm(68, function()
				cg_stripesettop:hidden(0)
				cg_stripesetbottom:hidden(0)
				
				cg_diamond:hidden(0)
				cg_diamond:y(scy+600)
				cg_circle:hidden(0)
				cg_circle:y(scy-600)
			end, true)
			
			me(68, 4, scy-200, scy, function(a) cg_stripesettop:y(a) end, 'len', inOutExpo)
			me(68, 4, scy+200, scy, function(a) cg_stripesetbottom:y(a) end, 'len', inOutExpo)
			me(70, 4, scy+500, scy, function(a) cg_diamond:y(a) end, 'len', inOutExpo)
			
			for pn = 1, 4 do
				if pn % 2 == 0 then
					m(72, 200, '*-1 100 stealth', 'end', pn)
				end
			end
			
			local stealthtable = {{0, 0}, {1, 1}, {2, 1}, {3, 0}}
			for i, v in ipairs(stealthtable) do
				for pn = 1, 2 do
					if v[2] == 1 then
						m(68, 200, '*-1 100 stealth' .. v[1], 'end', pn)
					end
				end
				for pn = 3, 4 do
					if v[2] == 0 then
						m(68, 200, '*-1 100 stealth' .. v[1], 'end', pn)
					end
				end
			end
			for pn = 1, 3 do
				m(72, 200, '*-1 100 hidenoteflashes, *-1 100 dark', 'end', pn)
			end
			
			for i = 72, 167 do
				for pn = 1, 4 do
					if pn % 2 == 1 then
						mm(i, function() GAMESTATE:ApplyModifiers('*-1 0 centered2') end, false)
						m(i, 1, '*2 180 centered2', 'len', pn)
					end
				end
				
				me(i, 1, 1.54, 1.5, function(a) cg_sexgrid:zoom(a) end, 'len', outExpo)
			end
			
			for i = 72, 135 do --ing your mom
				me(i - 0.5, 0.5, 100, 120, 'zoomx', 'len', inCirc)
				me(i - 0.5, 0.5, 100, 85, 'zoomy', 'len', inCirc)
				me(i, 0.5, 120, 100, 'zoomx', 'len', outCirc)
				me(i, 0.5, 85, 100, 'zoomy', 'len', outCirc)
			end
			
			for i = 136, 167 do
				me(i - 0.5, 0.5, 100, 110, 'zoomx', 'len', inCirc)
				me(i - 0.5, 0.5, 100, 95, 'zoomy', 'len', inCirc)
				me(i, 0.5, 110, 100, 'zoomx', 'len', outCirc)
				me(i, 0.5, 95, 100, 'zoomy', 'len', outCirc)
			end
			
			local cg_toggle = 1
			for i = 72, 96, 4 do
				mb(i, 4, 0, 10*cg_toggle, function(a) cg_roty = a end, outCubic, inCubic)
				mb(i, 4, 0, 10*cg_toggle, function(a) cg_roty2 = a end, outCubic, inCubic)
				
				cg_toggle = -cg_toggle
			end
			for i = 104, 132, 4 do
				mb(i, 4, 180, 180+25*cg_toggle, function(a) cg_roty = a end, outCubic, inCubic)
				mb(i, 4, 180, 180+25*cg_toggle, function(a) cg_roty2 = a end, outCubic, inCubic)
				
				cg_toggle = -cg_toggle
			end
			
			for i = 72, 134, 2 do
				mb(i, 1, 0, 25, 'invert', outCirc, inCirc)
				mb(i+1, 1, 0, -25, 'invert', outCirc, inCirc)
			end
			
			local cg_toggle2 = 1
			for i, v in ipairs(shopping_cart) do
				mb(v[1], 1, 0, 100*cg_toggle2, 'tipsy', outCubic, inCubic)
				mb(v[1], 1, 0, 10*cg_toggle2, 'dizzy', outCubic, inCubic)
				
				cg_toggle2 = -cg_toggle2
			end
			
			for i = 95, 97, 2 do
				mb(i, 1, 0, 10, function(a) cg_rotz = a end, outCirc, inCirc)
				mb(i, 1, 0, 20, 'skewy', outCirc, inCirc)
				mb(i+1, 1, 0, -10, function(a) cg_rotz = a end, outCirc, inCirc)
				mb(i+1, 1, 0, -20, 'skewy', outCirc, inCirc)
			end
			
			me(100, 4, 0, 180, function(a) cg_roty = a end, 'len', inOutExpo)
			me(100, 4, 0, 180, function(a) cg_roty2 = a end, 'len', inOutExpo)
			me(100, 4, -70, -110, function(a) cg_rotx = a end, 'len', inOutExpo)
			me(100, 4, -110, -70, function(a) cg_rotx2 = a end, 'len', inOutExpo)
			me(100, 4, 0, 100, 'flip', 'len', inOutExpo, nil, 28)
			for pn = 1, 2 do
				me(100, 4, -78, -78, 'movez', 'len', inOutExpo, pn, 32)
			end
			for pn = 3, 4 do
				me(100, 4, 78, 78, 'movez', 'len', inOutExpo, pn, 32)
			end
			
			me(102, 4, scy, scy-500, function(a) cg_diamond:y(a) end, 'len', inOutExpo)
			me(102, 4, scy+500, scy, function(a) cg_circle:y(a) end, 'len', inOutExpo)
			me(102, 4, 248, 193, function(a) cg_stripeR = a end, 'len', inOutExpo)
			me(102, 4, 180, 237, function(a) cg_stripeG = a end, 'len', inOutExpo)
			me(102, 4, 0, 56, function(a) cg_stripeB = a end, 'len', inOutExpo)
			me(102, 4, -5, 5, function(a) cg_stripesettop:rotationz(a) cg_stripesetbottom:rotationz(a) end, 'len', inOutExpo)
			
			me(104, 4, -300, 0, 'tinyz', 'len', outExpo)
			me(104, 4, -150, 0, 'tinyy', 'len', outExpo)
			me(104, 4, 30, 0, 'stealth0', 'len', outExpo, 1) -- lol
			me(104, 4, 30, 0, 'stealth3', 'len', outExpo, 1)
			me(104, 4, 30, 0, 'stealth1', 'len', outExpo, 3)
			me(104, 4, 30, 0, 'stealth2', 'len', outExpo, 3)			
			
			mb(112, 1, 0, 100, 'tipsy', outCubic, inCubic)
			mb(112, 1, 0, 20, 'skewx', outCubic, inCubic)
			mb(113, 1, 0, -100, 'tipsy', outCubic, inCubic)
			mb(113, 1, 0, -20, 'skewx', outCubic, inCubic)
			mb(114, 1, 0, 100, 'tipsy', outCubic, inCubic)
			mb(114, 1, 0, 20, 'skewx', outCubic, inCubic)
			
			mb(118, 1, 0, -150, 'tipsy', outCubic, inCubic)
			mb(118, 1, 0, 20, 'dizzy', outCubic, inCubic)
			mb(119, 1, 0, 150, 'tipsy', outCubic, inCubic)
			mb(119, 1, 0, -20, 'dizzy', outCubic, inCubic)
			
			mb(120, 1, 0, 5, function(a) cg_rotz = a end, outCirc, inCirc)
			mb(120, 1, 0, 30, 'skewy', outCirc, inCirc)
			mb(121, 1, 0, -5, function(a) cg_rotz = a end, outCirc, inCirc)
			mb(121, 1, 0, -30, 'skewy', outCirc, inCirc)
			
			for i = 104, 128, 8 do
				me(i, 4, 0, -50, 'movex1', 'len', inOutExpo)
				me(i, 4, 0, 50, 'movex2', 'len', inOutExpo)
				
				me(i+4, 4, -50, 0, 'movex1', 'len', inOutExpo)
				me(i+4, 4, 50, 0, 'movex2', 'len', inOutExpo)
			end
			
			me(132, 4, -110, 70, function(a) cg_rotx = a end, 'len', inOutExpo)
			me(132, 4, -70, 110, function(a) cg_rotx2 = a end, 'len', inOutExpo)
			me(132, 4, -180, 0, function(a) cg_roty = a end, 'len', inOutExpo)
			me(132, 4, -180, 0, function(a) cg_roty2 = a end, 'len', inOutExpo)
			me(136, 4, 0, 0, function(a) cg_roty = a end, 'len', inOutExpo) -- LEAVE MY FUCKING HOUSE
			me(136, 4, 0, 0, function(a) cg_roty2 = a end, 'len', inOutExpo)
			me(132, 4, 100, 0, 'flip', 'len', inOutExpo, nil, 200 - 136) 
			for pn = 1, 2 do
				me(132, 4, -78, -130, 'movez', 'len', inOutExpo, pn, 200 - 136)
			end
			for pn = 3, 4 do
				me(132, 4, 78, 130, 'movez', 'len', inOutExpo, pn, 200 - 136)
			end
			me(132, 200, 0, 0, 'dark', 'end', linear, 2)
			me(132, 200, 0, 0, 'hidenoteflashes', 'end', linear, 2)
			
			me(132, 4, scy, scy+500, function(a) cg_circle:y(a) end, 'len', inOutExpo)
			me(132, 4, scy, scy-200, function(a) cg_stripesettop:y(a) end, 'len', inOutExpo)
			me(132, 4, scy, scy+200, function(a) cg_stripesetbottom:y(a) end, 'len', inOutExpo)			
				
			me(132, 4, scy-1000, scy, function(a) for c = 0, 7 do _G['cg_itg'..c]:y(a) end end, 'len', inOutExpo)
			me(132, 4, 20, 0, function(a) cg_sexgrid:rotationz(a) end, 'len', inOutExpo)
			
			mm(132, function()
				for c = 0, 7 do
					_G['cg_itg'..c]:diffusealpha(0)
				end					
				cg_itg0:diffusealpha(1)
			end, false)
			
			-- trans ition sex tion
			for i = 136, 199 do
				local curbg = modulo(i, 8)
				
				mm(i, function()
					for c = 0, 7 do
						_G['cg_itg'..c]:diffusealpha(0)
					end					
					_G['cg_itg'..curbg]:diffusealpha(1)
				end, false)
			end
			
			me(149, 4, 360, 0, function(a) cg_roty = a end, 'len', inOutExpo) -- so why did i make two roty auxvars again
			me(149, 4, 360, 0, function(a) cg_roty2 = a end, 'len', inOutExpo)
			
			--me(166, 2, -360, 0, function(a) cg_roty = a end, 'len', inExpo)
			--me(166, 2, -360, 0, function(a) cg_roty2 = a end, 'len', inExpo)
			
			mb(163, 2, 0, 30, 'skewx', outExpo, inExpo)
			mb(165, 2, 0, -20, 'skewx', outExpo, inExpo)
			
			for i, v in ipairs(donk) do
				if v[2] == 0 then
					mb(v[1], v[4], 0, 70, 'tipsy', outCirc, inCirc)
					mb(v[1], v[4], 0, -20, function(a) cg_roty = a end, outCirc, inCirc)
					mb(v[1], v[4], 0, -20, function(a) cg_roty2 = a end, outCirc, inCirc)
				else
					mb(v[1], v[4], 0, -70, 'tipsy', outCirc, inCirc)
					mb(v[1], v[4], 0, 20, function(a) cg_roty = a end, outCirc, inCirc)
					mb(v[1], v[4], 0, 20, function(a) cg_roty2 = a end, outCirc, inCirc)
				end
			end
			
			for i, v in ipairs(shitdick4000) do
				me(v[1], 2, -150, 0, 'tiny', 'len', outExpo)
				me(v[1], 2, -150, 0, 'tinyz', 'len', outExpo)
			end
			
			for i = 168, 180, 4 do
				me(i-1, 2, -360, 0, function(a) cg_roty = a end, 'len', inOutExpo)
				me(i-1, 2, -360, 0, function(a) cg_roty2 = a end, 'len', inOutExpo)
				me(i+1, 2, 360, 0, function(a) cg_roty = a end, 'len', inOutExpo)
				me(i+1, 2, 360, 0, function(a) cg_roty2 = a end, 'len', inOutExpo)
			end
			
			for i = 168, 182, 2 do			
				me(i - 1, 1, 100, 130, 'zoomx', 'len', inCirc)
				me(i - 1, 1, 100, 85, 'zoomy', 'len', inCirc)
				me(i, 1, 130, 100, 'zoomx', 'len', outCirc)
				me(i, 1, 85, 100, 'zoomy', 'len', outCirc)
				
				me(i, 2, 1.1, 1, function(a) for c = 0, 7 do _G['cg_itg'..c]:zoom(a) end end, 'len', outExpo)
			end
			me(182, 4, -360, 0, function(a) cg_roty = a end, 'len', inOutExpo)
			me(182, 4, -360, 0, function(a) cg_roty2 = a end, 'len', inOutExpo)
			
			for i = 168, 176, 8 do
				me(i, 2, 0, 100, 'invert', 'len', outExpo)
				me(i+2, 2, 100, 0, 'invert', 'len', outExpo)
				me(i+4, 2, 0, 100, 'flip', 'len', outExpo)
				me(i+6, 2, 100, 0, 'flip', 'len', outExpo)
			end
			
			for i = 184, 198, 2 do
				me(i, 1, 0, 100, 'invert', 'len', outExpo)
				me(i, 1, -100, 0, 'tinyx', 'len', outExpo)
				mb(i, 1, 0, 20, 'skewx', outExpo, inExpo, 1)
				mb(i, 1, 0, 20, 'skewx', outExpo, inExpo, 2)
				mb(i, 1, 0, -20, 'skewx', outExpo, inExpo, 3)
				mb(i, 1, 0, -20, 'skewx', outExpo, inExpo, 4)
				
				me(i+1, 1, 100, 0, 'invert', 'len', outExpo)
				me(i+1, 1, -100, 0, 'tinyx', 'len', outExpo)
				mb(i+1, 1, 0, -20, 'skewx', outExpo, inExpo, 1)
				mb(i+1, 1, 0, -20, 'skewx', outExpo, inExpo, 2)
				mb(i+1, 1, 0, 20, 'skewx', outExpo, inExpo, 3)
				mb(i+1, 1, 0, 20, 'skewx', outExpo, inExpo, 4)
			end
			
			for i = 184, 199 do
				if i < 196 then
					me(i - 0.5, 0.5, 100, 110, 'zoomx', 'len', inExpo)
					me(i - 0.5, 0.5, 100, 95, 'zoomy', 'len', inExpo)
					me(i, 0.5, 110, 100, 'zoomx', 'len', outExpo)
					me(i, 0.5, 95, 100, 'zoomy', 'len', outExpo)
				end
				
				me(i, 1, 1.1, 1, function(a) for c = 0, 7 do _G['cg_itg'..c]:zoom(a) end end, 'len', outExpo)
			end			
			
			me(190, 4, 360, 0, function(a) cg_roty = a end, 'len', inOutExpo)
			me(190, 4, 360, 0, function(a) cg_roty2 = a end, 'len', inOutExpo)
			
			me(192, 8, 70, 70 - 360*2, function(a) cg_rotx = a end, 'len', inSine)
			me(192, 8, 110, 110 + 360*2, function(a) cg_rotx2 = a end, 'len', inSine)
			
			me(192, 8, 100, 150, 'zoomx', 'len', inSine)
			me(192, 8, 0, 1, function(a) cg_whitetop:diffusealpha(a) end, 'len', inOutSine)
			
			mpf(196, 200, function(beat) -- lol
				GAMESTATE:ApplyModifiers('*-1 '..(cg_shitmult*math.random()*200)..' bumpyx')
				GAMESTATE:ApplyModifiers('*-1 '..(cg_shitmult*math.random()*200)..' bumpyxoffset')
				GAMESTATE:ApplyModifiers('*-1 '..(cg_shitmult*math.random()*200)..' bumpyxperiod')
				GAMESTATE:ApplyModifiers('*-1 '..(cg_shitmult*math.random()*200/5)..' bumpy')
				GAMESTATE:ApplyModifiers('*-1 '..(cg_shitmult*math.random()*200)..' bumpyoffset')
				GAMESTATE:ApplyModifiers('*-1 '..(cg_shitmult*math.random()*200)..' bumpyperiod')
			end)			
			
			me(196, 200, 0, 1, function(a) cg_shitmult = a end, 'end', outCubic)
			me(196, 4, 0, 200, 'longholds', 'len', outSine)
			me(200, 1, 0, 0, function(a) cg_shitmult = a end, 'end', linear)
			
			-- hoooooo			
			for i = 204, 299 do
				local curbg = modulo(i, 8)
				
				mm(i, function()
					for c = 0, 7 do
						_G['cg_itg'..c]:diffusealpha(0)
					end					
					_G['cg_itg'..curbg]:diffusealpha(0.3)
				end, false)
			end
			me(200, 1, -30, -30, function(a) cg_rotx = a end, 'len', linear)
			me(200, 1, 0, 0, function(a) cg_roty = a end, 'len', linear)
			me(200, 1, 0, 0, function(a) cg_rotz = a end, 'len', linear)
			me(200, 1, 0, 0, 'movez', 'len', linear)
			me(200, 1, 0, 0, 'movex', 'len', linear)
			
			mpf(200, 364, function(beat)
				for pn = 1, 2 do
					GAMESTATE:ApplyModifiers(rotateAndCounter(cg_rotx, cg_roty,cg_rotz, pn), pn)
				end
				
				for i,v in ipairs({cg_stripetop, cg_dashtop1, cg_dashtop2, cg_stripebottom, cg_dashbottom1, cg_dashbottom2}) do 
					v:diffuse(cg_stripeR/255, cg_stripeG/255, cg_stripeB/255, 0.8)
				end
				
			end)
			SpawnPlayers(200, 3, 4, 'despawn', true)
			mm(200, function() 
				cg_whitetop:diffusealpha(0) 
				cg_blacktop:diffusealpha(1) 
				
				for c = 0, 7 do
					_G['cg_itg'..c]:diffusealpha(0)
				end
				
				for pn = 1, 2 do
					local b = _G['jud'..pn..'p']				
					local c = _G['com'..pn..'p']
					b:hidden(1)
					c:hidden(1)
				end
				
				cg_stripesettop:y(0)
				cg_stripesettop:x(scx-1000)
				cg_stripesettop:rotationz(-95)
				cg_stripesetbottom:y(0)
				cg_stripesetbottom:x(scx+1000)
				cg_stripesetbottom:rotationz(-95)
				
				cg_stripeR = 181
				cg_stripeG = 228
				cg_stripeB = 0
				
				cg_dashbottom1:texcoordvelocity(-0.3, 0, 0)
				cg_dashbottom2:texcoordvelocity(-0.3, 0, 0)
			end, true)
			mm(202, function()
				for pn = 1, 2 do
					local b = _G['jud'..pn..'p']				
					local c = _G['com'..pn..'p']
					b:hidden(0)
					c:hidden(0)
				end
			end, true)
			mm(201, function() cg_blacktop:diffusealpha(0) end, true)
			mm(200, function() cg_black:diffusealpha(1) end, true)
			
			me(201, 1, 0, 0, function(a) cg_black:cropleft(a) cg_black:cropright(a) end, 'len', linear)
			me(200, 1, 0, 0, 'bumpy', 'len', linear)
			me(200, 1, 0, 0, 'bumpyx', 'len', linear) -- LEAVE MY HOUSE
			
			m(200, 202.5, '*-1 90 stealth, *-1 dark, *-1 hidenoteflashes', 'end')
			m(200, 203, '*-1 0.7x', 'end')
			m(200, 204, '*-1 2000 arrowpathsize, *-1 150 arrowpathdrawsize, *-1 -100 arrowpathdrawsizeback', 'end')
			
			m(200, 300, '*-1 centered, *-1 70 zoom', 'end')
			m(200, 364, '*-1 sudden, *-1 500 suddenoffset, *-1 150 drawsize', 'end')
			m(200, 300, '*-1 99.9 reverse', 'end', 2)			
			
			me(202, 2, 0, 0.5, function(a) cg_black:cropleft(a) end, 'len', inOutCirc)
			me(202, 2, 0, 0.5, function(a) cg_black:cropright(a) end, 'len', inOutCirc)
			
			me(202, 2, scx-800, scx-50, function(a) cg_stripesettop:x(a) end, 'len', inOutExpo)
			me(202, 2, scx+800, scx+50, function(a) cg_stripesetbottom:x(a) end, 'len', inOutExpo)
			
			mm(204, function() cg_black:diffusealpha(0) cg_sexgrid:diffusealpha(0.1) end, true)			
			me(204, 300, 0, -50, function(a)  cg_sexgrid:rotationz(a) end, 'end', linear)
			
			me(202, 1, 0, 0, 'stealth', 'len', linear, 2)
			me(202, 1, 0, 0, 'dark', 'len', linear, 2)
			me(202, 2, -100, 0, 'tiny', 'len', outExpo, 2) 
			me(202, 2, 100, 0, 'arrowpath', 'len', outExpo, 2) 
			
			me(202.5, 0.5, 0, 0, 'stealth', 'len', linear, 1)
			me(202.5, 0.5, 0, 0, 'dark', 'len', linear, 1)
			me(202.5, 2, -100, 0, 'tiny', 'len', outExpo, 1) 
			me(202.5, 2, 100, 0, 'arrowpath', 'len', outExpo, 1) 
			
			me(203, 1, 0.7, 1.5, 'xmod', 'len', outSine, nil, 300) -- reaction funny ??? idk lol
			
			local cg_toggle3 = 1
			for i = 204, 292, 8 do
			
				if i < 268 then
					me(i, 4, 0, 100, 'flip', 'len', inOutExpo)
					mb(i+1, 2, 0, -100, 'tinyx', inExpo, outExpo)
					
					me(i+4, 4, 100, 0, 'flip', 'len', inOutExpo)
					mb(i+5, 2, 0, -100, 'tinyx', inExpo, outExpo)					
					
					me(i, 8, -30*cg_toggle3, 30*cg_toggle3, function(a) cg_rotx = a end, 'len', inOutSine)
					
					mb(i, 2, 0, 50*cg_toggle3, 'tipsy', outExpo, inExpo)
					mb(i, 2, 0, 50*cg_toggle3, 'drunkz', outExpo, inExpo)
					mb(i+2, 2, 0, -50*cg_toggle3, 'tipsy', outExpo, inExpo)
					mb(i+2, 2, 0, -50*cg_toggle3, 'drunkz', outExpo, inExpo)
					mb(i+3.5, 2, 0, 50*cg_toggle3, 'tipsy', outExpo, inExpo)
					mb(i+3.5, 2, 0, 50*cg_toggle3, 'drunkz', outExpo, inExpo)
				else
					--[[me(i, 4, 0, 100, 'invert', 'len', inOutExpo)
					mb(i+1, 2, 0, -100, 'tinyx', inExpo, outExpo)
					
					me(i+4, 4, 100, 0, 'invert', 'len', inOutExpo)
					mb(i+5, 2, 0, -100, 'tinyx', inExpo, outExpo)	]]
				end
				
				mb(i, 8, 0, 10*cg_toggle3, 'dizzy', outSine, inSine)
				mb(i, 8, 0, 120*cg_toggle3, 'drunk', outSine, inSine)
				
				
				cg_toggle3 = -cg_toggle3
			end
			
			for i = 204, 298 do
				me(i - 0.5, 0.5, 70, 80, 'zoomx', 'len', inCirc)
				me(i - 0.5, 0.5, 70, 65, 'zoomy', 'len', inCirc)
				me(i, 0.5, 80, 70, 'zoomx', 'len', outCirc)
				me(i, 0.5, 65, 70, 'zoomy', 'len', outCirc)
				
				me(i, 1, -50, 0, 'tiny', 'len', outExpo)
				me(i, 1, 1.52, 1.5, function(a) cg_sexgrid:zoom(a) end, 'len', outExpo)
				me(i, 1, 1.05, 1, function(a) for c = 0, 7 do _G['cg_itg'..c]:zoom(a) end end, 'len', outExpo)
			end
			
			me(204, 236, 0, -360*4, function(a) cg_rotz = a end, 'end', inOutQuad)
			me(236, 268, 0, 360*4, function(a) cg_rotz = a end, 'end', inOutQuad)
			
			mb(234, 1, 0, 60, 'skewy', outExpo, inExpo)
			mb(234, 1, 0, 20, 'tipsy', outExpo, inExpo)
			mb(235, 1, 0, -60, 'skewy', outExpo, inOutExpo)
			mb(235, 1, 0, -20, 'tipsy', outExpo, inOutExpo)
			
			me(234, 2, 181, 141, function(a) cg_stripeR = a end, 'len', inOutExpo)
			me(234, 2, 228, 25, function(a) cg_stripeG = a end, 'len', inOutExpo)
			me(234, 2, 0, 194, function(a) cg_stripeB = a end, 'len', inOutExpo)
			
			me(236, 4, -200, 0, 'tiny', 'len', outExpo)
			me(236, 4, 50, 0, 'stealth', 'len', outExpo)
			
			me(268, 298, 0, 360, function(a) cg_rotz = a end, 'end', inOutQuad)
			me(268, 298, -30, 0, function(a) cg_rotx = a end, 'end', inOutQuad)
			me(268, 298, -360*3, 0, function(a) cg_roty = a end, 'end', inOutCirc)
			
			mb(266, 1, 0, -60, 'skewy', outExpo, inExpo)
			mb(266, 1, 0, 20, 'tipsy', outExpo, inExpo)
			mb(267, 1, 0, 60, 'skewy', outExpo, inOutExpo)
			mb(267, 1, 0, -20, 'tipsy', outExpo, inOutExpo)			
			
			me(268, 4, -200, 0, 'tiny', 'len', outExpo)
			me(268, 4, 50, 0, 'stealth', 'len', outExpo)
			
			me(266, 2, 141, 248, function(a) cg_stripeR = a end, 'len', inOutExpo)
			me(266, 2, 25, 180, function(a) cg_stripeG = a end, 'len', inOutExpo)
			me(266, 2, 194, 0, function(a) cg_stripeB = a end, 'len', inOutExpo)
			me(266, 4, scy-500, scy, function(a) cg_diamond:y(a) end, 'len', inOutExpo)		
			me(266, 4, -95, -85, function(a) cg_stripesettop:rotationz(a) cg_stripesetbottom:rotationz(a) end, 'len', inOutExpo)	
			
			mb(291, 2, 0, 100, 'invert', outExpo, outExpo)
			mb(293, 2, 0, 100, 'invert', outExpo, outExpo)
			--mb(296, 4, 0, 100, 'flip', inOutExpo, inOutExpo)
			
			-- almost done :)
			me(298, 4, -360, 0, function(a) cg_rotz = a end, 'len', inOutExpo)
			me(298, 4, 0, 100, function(a) cg_pad = a end, 'len', inOutExpo)
			me(298, 4, 99.9, 0, 'reverse', 'len', inOutExpo, 2)
			me(298, 4, 70, 100, 'zoom', 'len', inOutExpo)
			me(298, 4, 100, 0, 'centered', 'len', inOutExpo)		
			
			me(298, 4, scy, scy+500, function(a) cg_diamond:y(a) end, 'len', inOutExpo)		
			me(298, 4, scy-500, scy, function(a) cg_circle:y(a) end, 'len', inOutExpo)
			me(298, 4, scy, scy+1000, function(a) for c = 0, 7 do _G['cg_itg'..c]:y(a) end end, 'len', inOutExpo)
			me(298, 4, 248, 193, function(a) cg_stripeR = a end, 'len', inOutExpo)
			me(298, 4, 180, 237, function(a) cg_stripeG = a end, 'len', inOutExpo)
			me(298, 4, 0, 56, function(a) cg_stripeB = a end, 'len', inOutExpo)
			
			for pn = 1, 2 do
				for c = 0, 3 do
					if c % 2 == 1 and pn == 1 then
						m(300, 364, '*-1 stealth' .. c .. ', *-1 dark' .. c .. ', *-1 hidenoteflashes' .. c, 'end', 1)
					elseif c % 2 == 0 and pn == 2 then 
						m(300, 364, '*-1 stealth' .. c .. ', *-1 dark' .. c .. ', *-1 hidenoteflashes' .. c, 'end', 2)
					end
				end
			end
			
			local cg_toggle4 = 1 
			for i = 300, 324, 8 do
				mb(i, 4, 0, 40, 'skewx', outCirc, inCirc, 1)
				mb(i, 4, 0, -40, 'noteskew', outCirc, inCirc, 1)
				mb(i, 4, 0, -40, 'skewx', outCirc, inCirc, 2)
				mb(i, 4, 0, 40, 'noteskew', outCirc, inCirc, 2)
				mb(i, 4, 0, 30, function(a) cg_rotx = a end, outCirc, inCirc)
				
				mb(i+4, 4, 0, -40, 'skewx', outCirc, inCirc, 1)
				mb(i+4, 4, 0, 40, 'noteskew', outCirc, inCirc, 1)
				mb(i+4, 4, 0, 40, 'skewx', outCirc, inCirc, 2)
				mb(i+4, 4, 0, -40, 'noteskew', outCirc, inCirc, 2)
				mb(i+4, 4, 0, -30, function(a) cg_rotx = a end, outCirc, inCirc)
				
				mb(i, 8, 0, 30*cg_toggle4, function(a) cg_roty = a end, outCirc, inCirc)
				
				cg_toggle4 = -cg_toggle4
			end
			
			for i = 300, 328, 4 do
				for c = 0, 3 do
					me(i + c, 1, -100, 0, 'tiny'..c, 'len', outCubic)
				end
			end			
			me(300, 4, -50, -180, function(a)  cg_sexgrid:rotationz(a) end, 'len', inOutCirc)
			
			mb(308.5, 1, 0, 10, function(a) cg_rotz = a end, outCirc, inCirc)
			mb(308.5, 1, 0, -20, 'skewy', outCirc, inCirc)
			mb(309.5, 1, 0, -10, function(a) cg_rotz = a end, outCirc, inCirc)
			mb(309.5, 1, 0, 20, 'skewy', outCirc, inCirc)
			mb(310.5, 1, 0, 10, function(a) cg_rotz = a end, outCirc, inCirc)
			mb(310.5, 1, 0, -20, 'skewy', outCirc, inCirc)
			
			mb(314, 1, 0, -200, 'tipsy', outCirc, inCirc)
			mb(314, 1, 0, 20, 'dizzy', outCirc, inCirc)
			mb(315, 1, 0, 200, 'tipsy', outCirc, inCirc)
			mb(315, 1, 0, -20, 'dizzy', outCirc, inCirc)
			mb(314, 2, 0, 100, 'invert', outCirc, inCirc)			
			
			me(316, 3, 0, -180, function(a) cg_rotz = a end, 'len', inOutCirc) 
			me(316, 319, 0, 100, 'flip', 'end', inOutCirc, nil, 330) 
			
			me(330, 4, 100, 50, 'flip', 'len', inOutExpo, nil, 50) -- idc about sustains anymore lol
			me(330, 4, 180, -180, function(a) cg_rotz = a end, 'len', inOutExpo)
			
			me(330, 4, scy, scy+500, function(a) cg_circle:y(a) end, 'len', inOutExpo)
			me(330, 4, scy-1000, scy, function(a) for c = 0, 7 do _G['cg_itg'..c]:y(a) end end, 'len', inOutExpo)				
			for i = 332, 363 do
				local curbg = modulo(i, 8)
				
				mm(i, function()
					for c = 0, 7 do
						_G['cg_itg'..c]:diffusealpha(0)
					end					
					_G['cg_itg'..curbg]:diffusealpha(0.3)
				end, false)
			end
			
			me(298, 2, 0, 0, function(a) cg_rotmult = a end, 'len', linear)
			me(298, 2, 0, 0, function(a) cg_pad = a end, 'len', linear)
			mpf(330, 364, function(beat)				
				for pn = 1,2 do
					for c = 0, 1 do
						GAMESTATE:ApplyModifiers('*-1 '..cg_pad*math.sin(cg_turn+math.abs(c-1)*2/1.25) ..'% movex'..c, pn)
						GAMESTATE:ApplyModifiers('*-1 '..cg_pad*math.cos(cg_turn+math.abs(c-1)*2/1.25) ..'% movez'..c, pn)
					end
					for c = 2, 3 do
						GAMESTATE:ApplyModifiers('*-1 '..cg_pad*math.sin(cg_turn+c*2/1.25) ..'% movex'..c, pn)
						GAMESTATE:ApplyModifiers('*-1 '..cg_pad*math.cos(cg_turn+c*2/1.25) ..'% movez'..c, pn)
					end		
					cg_rotx = cg_rotmult*math.sin(beat*cg_speed)
					cg_rotz = -180 + cg_rotmult*math.cos(beat*cg_speed)
				end				
			end)
			
			me(330, 4, 0, 175, function(a) cg_pad = a end, 'len', inOutExpo)
			me(332, 348, 0, 20, function(a) cg_rotmult = a end, 'end', outSine)
			me(348, 364, 20, 40, function(a) cg_rotmult = a end, 'end', inSine)
			me(332, 364, 1, 1.01, function(a) cg_speed = a end, 'end', inSine)
			
			me(330, 4, -85, -95, function(a) cg_stripesettop:rotationz(a) cg_stripesetbottom:rotationz(a) end, 'len', inOutExpo)	
			
			me(330, 4, 193, 248, function(a) cg_stripeR = a end, 'len', inOutExpo)
			me(330, 4, 237, 180, function(a) cg_stripeG = a end, 'len', inOutExpo)
			me(330, 4, 56, 0, function(a) cg_stripeB = a end, 'len', inOutExpo)
			
			me(346, 4, 248, 141, function(a) cg_stripeR = a end, 'len', inOutExpo)
			me(346, 4, 180, 25, function(a) cg_stripeG = a end, 'len', inOutExpo)
			me(346, 4, 0, 194, function(a) cg_stripeB = a end, 'len', inOutExpo)
			
			for i, v in ipairs(notebadta) do
				me(v[1], 2, -150, 0, 'tiny', 'len', outExpo)
				me(v[1], 2, cg_turn, cg_turn + 2, function(a) cg_turn = a end, 'len', outCirc)
				cg_turn = cg_turn + 2
				
				if v[1] < 356 then					
					me(v[1], 2, 70, 0, 'brake', 'len', outCirc)
				end
				
				me(v[1], 2, 1.15, 1, function(a) for c = 0, 7 do _G['cg_itg'..c]:zoom(a) end end, 'len', outExpo)		
			end
			
			me(356, 8, 175, 250, function(a) cg_pad = a end, 'len', inOutExpo)
			me(360, 4, 0, 2, function(a) cg_shitmult = a end, 'len', inSine)
			me(360, 4, 0, 200, 'longholds', 'len', outSine)
			mpf(360, 364, function(beat) -- turn it off
				GAMESTATE:ApplyModifiers('*-1 '..(cg_shitmult*math.random()*200)..' bumpyx')
				GAMESTATE:ApplyModifiers('*-1 '..(cg_shitmult*math.random()*200)..' bumpyxoffset')
				GAMESTATE:ApplyModifiers('*-1 '..(cg_shitmult*math.random()*200)..' bumpyxperiod')
				GAMESTATE:ApplyModifiers('*-1 '..(cg_shitmult*math.random()*200/5)..' bumpy')
				GAMESTATE:ApplyModifiers('*-1 '..(cg_shitmult*math.random()*200)..' bumpyoffset')
				GAMESTATE:ApplyModifiers('*-1 '..(cg_shitmult*math.random()*200)..' bumpyperiod')
			end)
			me(360, 4, 0, 1, function(a) cg_whitetop:diffusealpha(a) end, 'len', inOutSine)
			mm(364, function() cg_blacktop2:diffusealpha(1) end, true)			
			me(364, 1, 1, 0, function(a) cg_whitetop:diffusealpha(a) end, 'len', outCubic)
			
---------------------------------------------------------------------------------------
----------------------Sort the actions table-------------------------------------------
---------------------------------------------------------------------------------------
			
			function modtable_compare(a,b)
				return a[1] < b[1]
			end
			
			if table.getn(mod_actions) > 1 then
				table.sort(mod_actions, modtable_compare)
			end
			
			self:queuecommand('Update');
			
		end"
		
		UpdateCommand="%function(self)
			local beat = GAMESTATE:GetSongBeat()
			
			if beat>=0 and not checked then
					local ThingsToGrab = {'BPMDisplay','LifeFrame','ScoreFrame','Lyrics','SongBackground','SongForeground','Overlay','Underlay'}
					local ThingsToHide = {'BPMDisplay','LifeFrame','ScoreFrame','Overlay','Underlay'}
					for pn=1,8 do
						_G['P'..pn] = SCREENMAN:GetTopScreen():GetChild('PlayerP'..pn) or nil;
						if _G['P'..pn] then
							table.insert(mod_plr, _G['P'..pn])
							_G['jud'..pn]=_G['P'..pn]:GetChild('Judgment');
							_G['com'..pn]=_G['P'..pn]:GetChild('Combo');
							_G['jud'..pn]:hidden(1)
							_G['com'..pn]:hidden(1)
						end
						table.insert(ThingsToGrab,'LifeP'..pn); table.insert(ThingsToGrab,'ScoreP'..pn);
						table.insert(ThingsToHide,'LifeP'..pn); table.insert(ThingsToHide,'ScoreP'..pn);
					end	
					for i,v in ipairs(ThingsToGrab) do _G[v] = SCREENMAN:GetTopScreen():GetChild(v) or nil end	
					for i,v in ipairs(ThingsToHide) do if _G[v] then _G[v]:hidden(1) end end
				checked = true;
			end
			mod_curtime = GAMESTATE:GetSongTime()
			mod_lasttime = 0
			local deltatime = mod_curtime - mod_lasttime
			local deltatime = mod_curtime - mod_lasttime
			
			if P1 then P1:NoClearSplines(true) end
			if P2 then P2:NoClearSplines(true) end
			
			--p3/4/etc disabling judgment/combo stuff
			if P3 and P4 then
				for pn=3,8 do
					_G['P'..pn] = SCREENMAN:GetTopScreen():GetChild('PlayerP'..pn) or nil;
					if _G['P'..pn] then
						table.insert(mod_plr, _G['P'..pn])
						_G['jud'..pn]=_G['P'..pn]:GetChild('Judgment');
						_G['com'..pn]=_G['P'..pn]:GetChild('Combo');
						_G['jud'..pn]:hidden(1)
						_G['com'..pn]:hidden(1)
					end
				end
			end
			
---------------------------------------------------------------------------------------
----------------------Begin table handlers---------------------------------------------
---------------------------------------------------------------------------------------
			
			disable = false;
			if disable ~= true and checked then
				
				-----------------------
				-- Player mod resets --
				-----------------------
				if beat > mod_firstSeenBeat+0.1 then -- performance coding!! --
					for i=1,8 do
						GAMESTATE:ApplyModifiers('clearall',i)
						if _G['init_modsp'..i] then 
							GAMESTATE:ApplyModifiers(_G['init_modsp'..i],i)
						end
					end
				
				------------------------------------------------------------------------------
				-- custom mod reader by TaroNuke edited by WinDEU and re-stolen by TaroNuke --
				------------------------------------------------------------------------------
					for i,v in pairs(mods) do
						if v and table.getn(v) > 3 and v[1] and v[2] and v[3] and v[4] then
							if beat >=v[1] then
								if (v[4] == 'len' and beat <=v[1]+v[2]) or (v[4] == 'end' and beat <=v[2]) then
									if table.getn(v) == 5 then
										GAMESTATE:ApplyModifiers(v[3],v[5]);
									else
										GAMESTATE:ApplyModifiers(v[3]);
									end
								end
							end
						else
							v[1] = 0;
							v[2] = 0;
							v[3] = '';
							v[4] = 'error';
							SCREENMAN:SystemMessage('Bad mod in beat-based table (line '..i..')');
						end
					end
				
				-----------------------------------------------------------------------------------------------------
				-- WinDEU's time-based len/end version of the #swag custom mod reader #teamproofofconcept (c) 2015 --
				-----------------------------------------------------------------------------------------------------
					for i,v in pairs(mods2) do
						if v and table.getn(v) > 3 and v[1] and v[2] and v[3] and v[4] then
							if mod_time >=v[1] then
								if (v[4] == 'len' and mod_time <=v[1]+v[2]) or (v[4] == 'end' and mod_time <=v[2]) then
									if table.getn(v) == 5 then
										GAMESTATE:ApplyModifiers(v[3],v[5]);
									else
										GAMESTATE:ApplyModifiers(v[3]);
									end
								end
							end
						else
							v[1] = 0;
							v[2] = 0;
							v[3] = 'error';
							v[4] = 'error';
							SCREENMAN:SystemMessage('Bad mod in time-based table (line '..i..')');
						end
					end
				
				---------------------------------------
				-- Ease table (includes func_ease) --
				---------------------------------------
					for i,v in pairs(mods_ease) do
						if v and table.getn(v) > 6 and v[1] and v[2] and v[3] and v[4] and v[5] and v[6] and v[7] then
							if beat >=v[1] then
								if (v[6] == 'len' and beat <=v[1]+v[2]) or (v[6] == 'end' and beat <=v[2]) then
									local strength = v[7](beat - v[1], v[3], v[4] - v[3], v[6] == 'end' and v[2] - v[1] or v[2], v[10], v[11])
									if type(v[5]) == 'string' then
										local modstr = v[5] == 'xmod' and strength..'x' or (v[5] == 'cmod' and 'C'..strength or strength..' '..v[5])
										GAMESTATE:ApplyModifiers('*9999 '..modstr,v[8]);
									elseif type(v[5]) == 'function' then
										v[5](strength)
									end
								elseif (v[9] and ((v[6] == 'len' and beat <=v[1]+v[2]+v[9]) or (v[6] == 'end' and beat <=v[9]))) then
									if type(v[5]) == 'string' then
										local modstr = v[5] == 'xmod' and v[4]..'x' or (v[5] == 'cmod' and 'C'..v[4] or v[4]..' '..v[5])
										GAMESTATE:ApplyModifiers('*9999 '..modstr,v[8]);
									elseif type(v[5]) == 'function' then
										v[5](v[4])
									end
								end
							end
						else
							SCREENMAN:SystemMessage('Ease Error! (line '..i..' | beat: '.. v[1] .. ' | mod: '.. v[5] ..')');
						end
					end
				---------------------
				-- Perframe reader --
				---------------------
					if table.getn(mod_perframes)>0 then
						for i=1,table.getn(mod_perframes) do
							local a = mod_perframes[i]
							if beat > a[1] and beat < a[2] then
								a[3](beat,deltatime);
							end
						end
					end
				---------------------------------------
				-- Actions table --
				---------------------------------------
					while curaction<=table.getn(mod_actions) and GAMESTATE:GetSongBeat()>=mod_actions[curaction][1] do
						if mod_actions[curaction][3] or GAMESTATE:GetSongBeat() < mod_actions[curaction][1]+2 then
							if type(mod_actions[curaction][2]) == 'function' then
								mod_actions[curaction][2]()
							elseif type(mod_actions[curaction][2]) == 'string' then
								MESSAGEMAN:Broadcast(mod_actions[curaction][2]);
							end
						end
						curaction = curaction+1;
					end
				end				
			end
			
			mod_lasttime = mod_curtime
			--self:sleep(0.02);
			--self:queuecommand('Update');
			self:hidden(0);
			self:zoom(0);
			self:luaeffect('Update');

---------------------------------------------------------------------------------------
----------------------END DON'T TOUCH IT KIDDO-----------------------------------------
---------------------------------------------------------------------------------------
			
		end"
		
	/>
	
	<ZZLAER Type="ActorFrame" InitCommand="%function(self) judc = self end"><children>
	<LAER Type="ActorProxy" InitCommand="%function(self) jud1p = self end"
	GetProxyMessageCommand="%function(self) if P1 then self:SetTarget(P1:GetChild('Judgment')) end end"/>
	<LAER Type="ActorProxy" InitCommand="%function(self) jud2p = self end"
	GetProxyMessageCommand="%function(self) if P2 then self:SetTarget(P2:GetChild('Judgment')) end end"/>
	</children></ZZLAER>
	<ZZLAER Type="ActorFrame" InitCommand="%function(self) comc = self end"><children>
	<LAER Type="ActorProxy" InitCommand="%function(self) com1p = self end"
	GetProxyMessageCommand="%function(self) if P1 then self:SetTarget(P1:GetChild('Combo')) end end"/>
	<LAER Type="ActorProxy" InitCommand="%function(self) com2p = self end"
	GetProxyMessageCommand="%function(self) if P2 then self:SetTarget(P2:GetChild('Combo')) end end"/>
	</children></ZZLAER>
	
	<!--This is for the time based mod reader-->
	<BitmapText
		Font="Common Normal"
		Text="test"
		OnCommand="x,SCREEN_CENTER_X;y,SCREEN_CENTER_Y;effectclock,music;playcommand,SetTime;hidden,1"
		SetTimeCommand="%function(self) self:settext(self:GetSecsIntoEffect()); mod_time = tonumber(self:GetText()); self:sleep(0.02); self:queuecommand('SetTime'); end"
	/>
	
	<!-- ???????????? -->
	<Layer Type = "Quad" Var="cg_blacktop2"    
        InitCommand="xy,SCREEN_CENTER_X,SCREEN_CENTER_Y;zoomtowidth,SCREEN_WIDTH;zoomtoheight,SCREEN_HEIGHT;hidden,0;diffuse,0,0,0,0;"    
    />
	<Layer Type = "Quad" Var="cg_whitetop"    
        InitCommand="xy,SCREEN_CENTER_X,SCREEN_CENTER_Y;zoomtowidth,SCREEN_WIDTH;zoomtoheight,SCREEN_HEIGHT;hidden,0;diffuse,1,1,1,0;"    
    />
	<Layer Type = "Quad" Var="cg_blacktop"    
        InitCommand="xy,SCREEN_CENTER_X,SCREEN_CENTER_Y;zoomtowidth,SCREEN_WIDTH;zoomtoheight,SCREEN_HEIGHT;hidden,0;diffuse,0,0,0,0;"    
    />
	
	<!-- before you get all up in my ass, the misspelling is intentional -->
	<Layer
		File = "torienatext.png"
		OnCommand="%function(self)
			cg_triena = self
			self:x(SCREEN_CENTER_X)
			self:y(SCREEN_CENTER_Y)
			self:zoom(0.6)
			
			self:diffuse(1,1,1,0)
		end"
	/>
	<Layer
		File = "cgtext.png"
		OnCommand="%function(self)
			cg_chewin = self
			self:x(SCREEN_CENTER_X)
			self:y(SCREEN_CENTER_Y)
			self:zoom(0.6)
			
			self:diffuse(1,1,1,0)
		end"
	/>
	<Layer
		File = "cgaytext.png"
		OnCommand="%function(self)
			cg_gay = self
			self:x(SCREEN_CENTER_X)
			self:y(SCREEN_CENTER_Y)
			self:zoom(0.6)
			
			self:diffuse(1,1,1,0)
		end"
	/>
	
</children></ActorFrame></children></ActorFrame>